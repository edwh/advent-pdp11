	.TITLE	XFER3 - Hex File Transfer (Working Version)
	.IDENT	/V1.0/
;
;	XFER - Receive hex-encoded files via terminal
;	Based on working XFER2 structure
;
;	Protocol:
;	  :filename     - Start receiving file
;	  :0000:HH...   - Hex data line
;	  :END          - End of file
;
;	EMT 340 = .TTYIN, EMT 341 = .TTYOUT, EMT 350 = .EXIT

	.ASECT
	.=1000

START:	MOV	#HELLO,R1
	JSR	PC,PUTS
	CLR	TOTBYT
	CLR	FILCHN

; Main loop
WAIT:	JSR	PC,GETLIN	; Get a line
	TSTB	LINBUF		; Empty?
	BEQ	WAIT
	CMPB	LINBUF,#':	; Starts with ':'?
	BNE	WAIT

	; Check for :END
	CMPB	LINBUF+1,#'E
	BNE	NOTEND
	CMPB	LINBUF+2,#'N
	BNE	NOTEND
	CMPB	LINBUF+3,#'D
	BNE	NOTEND

	; It's :END - close and report
	TST	FILCHN
	BEQ	NOFIL
	CLR	FILCHN
	; Print DONE:count
	MOV	#MSGDON,R1
	JSR	PC,PUTS2	; No CRLF
	MOV	TOTBYT,R0
	JSR	PC,PRHEX4
	MOV	#15,R0
	EMT	341
	MOV	#12,R0
	EMT	341
	CLR	TOTBYT
	BR	WAIT

NOFIL:	MOV	#MSGERR,R1
	JSR	PC,PUTS
	BR	WAIT

NOTEND:	; Check for second colon (data line)
	MOV	#LINBUF+1,R0
	JSR	PC,FNDCOL
	TST	R0
	BNE	ISDATA

	; No second colon = filename
	MOV	#1,FILCHN	; Mark file open
	CLR	TOTBYT
	MOV	#MSGOK,R1
	JSR	PC,PUTS
	BR	WAIT

ISDATA:	; Hex data line
	TST	FILCHN
	BEQ	NODAT
	; R0 points after second colon
	; Skip 4 hex digits + colon (line number)
	ADD	#5,R0
	MOV	R0,R1		; R1 = pointer to hex data
	CLR	R4		; Byte count

NXTBYT:	MOVB	(R1)+,R2	; Get high nibble char
	BEQ	DONDAT
	CMPB	R2,#15		; CR?
	BEQ	DONDAT
	CMPB	R2,#12		; LF?
	BEQ	DONDAT
	CMPB	R2,#':		; Checksum separator?
	BEQ	DONDAT
	JSR	PC,HEXDIG	; Convert to nibble in R0
	ASL	R0
	ASL	R0
	ASL	R0
	ASL	R0
	MOV	R0,R3		; Save high nibble
	MOVB	(R1)+,R2	; Get low nibble char
	BEQ	DONDAT
	JSR	PC,HEXDIG
	BIS	R3,R0		; Combine
	MOVB	R0,BINBUF(R4)	; Store byte
	INC	R4
	BR	NXTBYT

DONDAT:	ADD	R4,TOTBYT
	MOV	#MSGOK,R1
	JSR	PC,PUTS
	BR	WAIT

NODAT:	MOV	#MSGERR,R1
	JSR	PC,PUTS
	BR	WAIT

; ============ Subroutines ============

; HEXDIG - Convert hex char in R2 to nibble in R0
HEXDIG:	CLR	R0
	CMPB	R2,#'9
	BGT	HX1
	MOVB	R2,R0
	SUB	#'0,R0
	RTS	PC
HX1:	CMPB	R2,#'F
	BGT	HX2
	MOVB	R2,R0
	SUB	#67,R0		; 'A'-10 = 55
	RTS	PC
HX2:	MOVB	R2,R0
	SUB	#127,R0		; 'a'-10 = 87
	RTS	PC

; FNDCOL - Find ':' in string at R0, return ptr after or 0
FNDCOL:	MOV	R0,R1
FC1:	MOVB	(R1)+,R0
	BEQ	FC2
	CMPB	R0,#':
	BEQ	FC3
	CMPB	R0,#15		; CR
	BEQ	FC2
	CMPB	R0,#12		; LF
	BNE	FC1
FC2:	CLR	R0
	RTS	PC
FC3:	MOV	R1,R0
	RTS	PC

; PUTS - Print string at R1 with CRLF
PUTS:	MOVB	(R1)+,R0
	BEQ	PUTS2E
	EMT	341
	BR	PUTS
PUTS2E:	MOV	#15,R0
	EMT	341
	MOV	#12,R0
	EMT	341
	RTS	PC

; PUTS2 - Print string at R1, no CRLF
PUTS2:	MOVB	(R1)+,R0
	BEQ	PUTS2R
	EMT	341
	BR	PUTS2
PUTS2R:	RTS	PC

; PRHEX4 - Print R0 as 4 hex digits
PRHEX4:	MOV	R0,-(SP)
	MOV	R0,R1
	SWAB	R1
	MOV	R1,R0
	JSR	PC,PRHEX2
	MOV	(SP)+,R0
	; Fall through

; PRHEX2 - Print low byte of R0 as 2 hex digits
PRHEX2:	MOV	R0,-(SP)
	ASR	R0
	ASR	R0
	ASR	R0
	ASR	R0
	BIC	#177760,R0
	JSR	PC,PRNIB
	MOV	(SP)+,R0
	BIC	#177760,R0
	; Fall through

; PRNIB - Print nibble in R0
PRNIB:	CMP	R0,#11		; 9 decimal = 11 octal
	BGT	PN1
	ADD	#'0,R0
	BR	PN2
PN1:	ADD	#67,R0		; 'A' - 10 = 55 = 67 octal
PN2:	EMT	341
	RTS	PC

; GETLIN - Read line into LINBUF
GETLIN:	MOV	#LINBUF,R1
	MOV	#80.,R2
GL1:	EMT	340
	MOVB	R0,(R1)+
	CMPB	R0,#15
	BEQ	GL2
	CMPB	R0,#12
	BEQ	GL2
	SOB	R2,GL1
GL2:	CLRB	(R1)
	RTS	PC

; ============ Data ============

HELLO:	.ASCII	/XFER3 V1.0/
	.BYTE	0
MSGOK:	.ASCII	/OK/
	.BYTE	0
MSGERR:	.ASCII	/ERR/
	.BYTE	0
MSGDON:	.ASCII	/DONE:/
	.BYTE	0
	.EVEN

LINBUF:	.BLKB	82.
BINBUF:	.BLKB	64.
TOTBYT:	.WORD	0
FILCHN:	.WORD	0

	.END	START
