0029  program pl0(tty,input);00040076  { PL/0 compiler, with syntax error recovery and even code generation }00040009const0040  norw=13; { no. of reserved words }0047  txmax=100; { length of identifier table }0042  nmax=5; { no. of digits in numbers }0038  al=10; { length of identifiers }0037  amax=2047; { maxmimum address }0038  levmax=3; { max. block nesting }0039  cxmax=200; { size of code array }0046  dolistcode=false; { list generated code}00040008type^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^0077  symbol=(nul,ident,number,plus,minus,times,slash,oddsym,eql,neq,lss,leq,0069	  gtr,geq,lparen,rparen,comma,semicolon,period,becomes,beginsym,0067	  endsym,ifsym,thensym,whilesym,dosym,callsym,constsym,varsym,0033	  procsym,writesym,readsym);0033  alfa=array [1..al] of char;0052  object=(constantobj,variableobj,procedureobj);0027  symset=set of symbol;0052  fct=(lit,opr,lod,sto,cal,int,jmp,jpc,wrt,inp);0024  instruction=record0014		f : fct;0020		l : 0..levmax;0018		a : 0..amax;0015	      end;00040007var0040  ch : char; { last character read }0040  sym : symbol; { last symbol read }0041  id : alfa; { last identifier read }0041  num : integer; { last number read }0039  cc : integer; { character count }0035  ll : integer; { line length }0023  kk,err : integer;0045  cx : integer; { code allocation index }0035  line : array [1..81] of char;0015  a : alfa;0045  code : array [0..cxmax] of instruction;0037  word : array [1..norw] of alfa;0039  wsym : array [1..norw] of symbol;0036  ssym : array [char] of symbol;^0047  mn : array [fct] of array [1..5] of char;0047  declbegsys,statbegsys,facbegsys : symset;0033  table : array [0..txmax] of0012  record0020    name : alfa;0029    case kind : object of0036	 constantobj : (val : integer);0055	 variableobj,procedureobj : (level,adr : integer);0010  end;0039  filename : array [1..20] of char;00040037  procedure error( n : integer );00040012   begin0050    writeln(tty,' ':cc-1,'^',n:2); err:=err+1;0011   end;00040032  procedure getsym; forward;0004^^^^^^^^^^^^^^^^^^^^^^^^^^0052  procedure test( s1,s2 : symset; n : integer );00040012   begin0026    if not (sym in s1)0012    then0014     begin0030      error(n); s1:=s1+s2;0042      while not (sym in s1) do getsym;0013     end;0011   end;00040023  procedure getsym;00040009  var0024    i,j,k : integer;00040024    procedure getch;00040014     begin0018      if cc=ll0014      then0016       begin0018	if eof(input)0009	then0011	 begin0051	  writeln(tty,'**** Program incomplete ****');0012	  halt;0010	 end;^^^^^^^^^^^^^^^^^^^^^^^^^^^0034	ll:=0; cc:=0; write(tty,' ');0029	while not eoln(input) do0011	 begin0061	  ll:=ll+1; read(input,ch); write(tty,ch); line[ll]:=ch;0010	 end;0045	writeln; ll:=ll+1; read(input,line[ll]);0015       end;0033      cc:=cc+1; ch:=line[cc];0013     end;00040012   begin0035    while ord(ch)<=32 do getch;0027    if ch in ['A'..'Z']0012    then0014     begin0015      k:=0;0017       repeat0012	if k<al0009	then0011	 begin0024	  k:=k+1; a[k]:=ch;0010	 end;0011	getch;0048       until not(ch in ['A'..'Z','0'..'9']);0018      if k>=kk0020      then kk:=k0014      else0017       repeat0026	a[kk]:=' '; kk:=kk-1;0022       until kk=k;0031      id:=a; i:=1; j:=norw;0017       repeat0020	k:=(i+j) div 2;0019	if id<=word[k]0017	then j:=k-1;0019	if id>=word[k]0017	then i:=k+1;0021       until i>j;0018      if i-1>j0027      then sym:=wsym[k]0026      else sym:=ident;0012     end0012    else0028     if ch in ['0'..'9']0013     then0016       begin0031	k:=0; num:=0; sym:=number;0012	 repeat0036	  num:=10*num+ord(ch)-ord('0');^^^0021	  k:=k+1; getch;0035	 until not (ch in ['0'..'9']);0014	if k>nmax0020	then error(30);0014       end0013     else0020       if ch=':'0015       then0011	 begin0013	  getch;0016	  if ch='='0011	  then0013	   begin0029	    sym:=becomes; getch;0011	   end0011	  else0016	  sym:=nul;0009	 end0015       else0011	 begin0028	  sym:=ssym[ch]; getch;0010	 end;0011   end;00040046  procedure gen( x : fct; y,z : integer );00040012   begin0019    if cx>cxmax0012    then0014     begin^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^0058      writeln(tty,'**** Program too long ****'); halt;0013     end;0024    with code[cx] do0014     begin0027      f:=x; l:=y; a:=z;0013     end;0017    cx:=cx+1;0011   end;00040057  procedure block( lev,tx : integer; fsys : symset );00040009  var0047    dx : integer; { data allocation index }0046    tx0 : integer; { initial table index }0045    cx0 : integer; { initial code index }00040038    procedure enter( k : object );00040014     begin0019      tx:=tx+1;0027      with table[tx] do0016       begin^0023	name:=id; kind:=k;0015	 case k of0020	  constantobj :0012			begin0019			 if num>amax0012			 then0014			  begin0028			   error(30); num:=0;0013			  end;0017			 val:=num;0011			end;0020	  variableobj :0012			begin0038			 level:=lev; adr:=dx; dx:=dx+1;0011			end;0033	  procedureobj : level:=lev;0010	 end;0015       end;0013     end;00040049    function position( id : alfa ) : integer;00040011    var0022      i : integer;00040014     begin0035      table[0].name:=id; i:=tx;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^0044      while table[i].name<>id do i:=i-1;0022      position:=i;0013     end;00040035    procedure constdeclaration;00040014     begin0022      if sym=ident0014      then0016       begin0012	getsym;0028	if sym in [eql,becomes]0009	then0011	 begin0021	  if sym=becomes0021	  then error(1);0014	  getsym;0020	  if sym=number0011	  then0013	   begin0036	    enter(constantobj); getsym;0011	   end0021	  else error(2);0009	 end0019	else error(3);0014       end0024      else error(4);0013     end;0004^^^^^^^^^^^^^0033    procedure vardeclaration;00040014     begin0022      if sym=ident0014      then0016       begin0032	enter(variableobj); getsym;0014       end0024      else error(4);0013     end;00040027    procedure listcode;00040011    var0022      i : integer;00040014     begin0028      if dolistcode=true0014      then0079      for i:=cx0 to cx-1 do with code[i] do writeln(i,' ',mn[f]:5,l:3,a:5);0013     end;00040045    procedure statement( fsys : symset );00040011    var0030      i,cx1,cx2 : integer;0004^^^^^^^^0048      procedure expression( fsys : symset );00040013      var0020	addop : symbol;00040037	procedure term( fsys : symset );00040008	var0022	  mulop : symbol;00040041	  procedure factor( fsys : symset );00040010	  var0021	    i : integer;00040013	   begin0033	    test(facbegsys,fsys,24);0034	    while sym in facbegsys do0015	     begin0023	      if sym=ident0015	      then0017	       begin0022		i:=position(id);0012		if i=00020		then error(11)0010		else0022		with table[i] do0019		 case kind of^^^^^^^^^^^^^0037		  constantobj : gen(lit,0,val);0045		  variableobj : gen(lod,lev-level,adr);0033		  procedureobj : error(21);0011		 end;0013		getsym;0015	       end0015	      else0025	       if sym=number0016	       then0012		 begin0019		  if num>amax0012		  then0014		   begin0028		    error(30); num:=0;0013		   end;0030		  gen(lit,0,num); getsym0010		 end0016	       else0020		 if sym=lparen0011		 then0014		   begin0044		    getsym; expression([rparen]+fsys);0023		    if sym=rparen0021		    then getsym^^^^^^^^^^^^^^^0025		    else error(22);0013		   end;0034	      test(fsys,[lparen],23);0014	     end;0012	   end;00040011	 begin0034	  factor(fsys+[times,slash]);0036	  while sym in [times,slash] do0013	   begin0056	    mulop:=sym; getsym; factor(fsys+[times,slash]);0023	    if mulop=times0026	    then gen(opr,0,4)0027	    else gen(opr,0,5);0012	   end;0010	 end;00040016       begin0027	if sym in [plus,minus]0009	then0011	 begin0051	  addop:=sym; getsym; term(fsys+[plus,minus]);0021	  if addop=minus^^^^^^^^^^^^^^^^^^^^^^^0025	  then gen(opr,0,1);0009	 end0034	else term(fsys+[plus,minus]);0033	while sym in [plus,minus] do0011	 begin0051	  addop:=sym; getsym; term(fsys+[plus,minus]);0020	  if addop=plus0024	  then gen(opr,0,2)0025	  else gen(opr,0,3);0010	 end;0015       end;00040047      procedure condition( fsys : symset );00040013      var0020	relop : symbol;00040016       begin0018	if sym=oddsym0009	then0011	 begin0046	  getsym; expression(fsys); gen(opr,0,6);0009	 end0009	else0011	 begin^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^0050	  expression([eql,neq,lss,gtr,leq,geq]+fsys);0048	  if not (sym in [eql,neq,lss,leq,gtr,geq])0021	  then error(20)0011	  else0013	   begin0046	    relop:=sym; getsym; expression(fsys);0023	     case relop of0030	      eql : gen(opr,0,8);0030	      neq : gen(opr,0,9);0031	      lss : gen(opr,0,10);0031	      geq : gen(opr,0,11);0031	      gtr : gen(opr,0,12);0031	      leq : gen(opr,0,13);0014	     end;0012	   end;0010	 end;0015       end;00040014     begin0022      if sym=ident0014      then^^^^^^^^^^^0016       begin0021	i:=position(id);0011	if i=00019	then error(11)0009	else0035	 if table[i].kind<>variableobj0021	 then error(12);0012	getsym;0019	if sym=becomes0016	then getsym0020	else error(13);0022	expression(fsys);0012	if i<>00050	then with table[i] do gen(sto,lev-level,adr);0014       end0014      else0025       if sym=callsym0015       then0011	 begin0014	  getsym;0020	  if sym<>ident0021	  then error(14)0011	  else0013	   begin0025	    i:=position(id);0015	    if i=00023	    then error(11)^^^^^^^^0013	    else0025	    with table[i] do0029	    if kind=procedureobj0036	    then gen(cal,lev-level,adr)0024	    else error(15);0016	    getsym;0012	   end;0009	 end0015       else0018	 if sym=ifsym0010	 then0013	   begin0049	    getsym; condition([thensym,dosym]+fsys);0023	    if sym=thensym0020	    then getsym0024	    else error(16);0031	    cx1:=cx; gen(jpc,0,0);0042	    statement(fsys); code[cx1].a:=cx;0011	   end0010	 else0023	   if sym=beginsym0012	   then0015	     begin^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^0054	      getsym; statement([semicolon,endsym]+fsys);0049	      while sym in [semicolon]+statbegsys do0017	       begin0022		if sym=semicolon0017		then getsym0021		else error(10);0041		statement([semicolon,endsym]+fsys);0016	       end;0024	      if sym=endsym0022	      then getsym0026	      else error(17);0013	     end0012	   else0025	     if sym=whilesym0014	     then0017	       begin0047		cx1:=cx; getsym; condition([dosym]+fsys);0028		cx2:=cx; gen(jpc,0,0);0018		if sym=dosym0017		then getsym^^^^^^^^^^^^0021		else error(18);0055		statement(fsys); gen(jmp,0,cx1); code[cx2].a:=cx;0015	       end0014	     else0027	       if sym=writesym0016	       then0012		 begin0033		  getsym; expression(fsys);0021		  gen(wrt,0,0);0010		 end0016	       else0021		 if sym=readsym0011		 then0014		   begin0017		    getsym;0023		    if sym<>ident0024		    then error(12)0014		    else0016		     begin0028		      i:=position(id);0018		      if i=00026		      then error(11)0033		      else with table[i] do^^^^^^^^^^^^^^^^^^^^^^^^^^^0031		      if kind=variableobj0016		      then0018		       begin0020			gen(inp,0,0);0030			gen(sto,lev-level,adr);0016		       end0027		      else error(25);0019		      getsym;0015		     end;0013		   end;0027      test(fsys,[],19);0013     end;00040012   begin0056    dx:=3; tx0:=tx; table[tx].adr:=cx; gen(jmp,0,0);0015     repeat0025      if sym=constsym0014      then0016       begin0012	getsym;0012	 repeat0024	  constdeclaration;0025	  while sym=comma do0013	   begin0034	    getsym; constdeclaration;^^^^^0012	   end;0023	  if sym=semicolon0018	  then getsym0021	  else error(5);0023	 until sym<>ident;0015       end;0023      if sym=varsym0014      then0016       begin0012	getsym;0012	 repeat0022	  vardeclaration;0025	  while sym=comma do0013	   begin0032	    getsym; vardeclaration;0012	   end;0023	  if sym=semicolon0018	  then getsym0021	  else error(5);0023	 until sym<>ident;0015       end;0030      while sym=procsym do0016       begin0012	getsym;0017	if sym=ident0009	then0011	 begin^^^^^^^^^^^^^^^^^^^^^^^^0035	  enter(procedureobj); getsym;0009	 end0019	else error(4);0021	if sym=semicolon0016	then getsym0019	else error(5);0038	block(lev+1,tx,[semicolon]+fsys);0021	if sym=semicolon0009	then0011	 begin0055	  getsym; test(statbegsys+[ident,procsym],fsys,6);0009	 end0019	else error(5);0015       end;0048      test(statbegsys+[ident],declbegsys,7);0038     until not(sym in declbegsys);0035    code[table[tx0].adr].a:=cx;0035    with table[tx0] do adr:=cx;0031    cx0:=cx; gen(int,0,dx);^^^^^^^^^^^^^^^^^^^^^^^^^^^^^0043    statement([semicolon,endsym]+fsys);0021    gen(opr,0,0);0024    test(fsys,[],8);0017    listcode;0011   end;00040026  procedure interpret;00040011  const0022    stacksize=500;00040009  var0060    p,b,t : integer; { program,base,topstack registers }0049    i : instruction; { instruction register }0054    s : array [1..stacksize] of integer; { stack }00040047    function base( l : integer ) : integer;00040011    var0023      b1 : integer;00040014     begin0016      b1:=b;0022      while l>0 do^^^^^^^^0016       begin0023	b1:=s[b1]; l:=l-1;0015       end;0019      base:=b1;0013     end;00040012   begin0016    writeln;0043    writeln('Start of interpretation');0016    writeln;0025    t:=0; b:=1; p:=0;0034    s[1]:=0; s[2]:=0; s[3]:=0;0015     repeat0029      i:=code[p]; p:=p+1;0019      with i do0020       case f of0010	lit :0016	      begin0028	       t:=t+1; s[t]:=a;0015	      end;0010	opr :0020	      case a of0015	       0 :0014		   begin0039		    t:=b-1; p:=s[t+3]; b:=s[t+2];0013		   end;^^^^^^^^^^^^^0028	       1 : s[t]:=-s[t];0015	       2 :0014		   begin0036		    t:=t-1; s[t]:=s[t]+s[t+1];0013		   end;0015	       3 :0014		   begin0036		    t:=t-1; s[t]:=s[t]-s[t+1];0013		   end;0015	       4 :0014		   begin0036		    t:=t-1; s[t]:=s[t]*s[t+1];0013		   end;0015	       5 :0014		   begin0040		    t:=t-1; s[t]:=s[t] div s[t+1];0013		   end;0037	       6 : s[t]:=ord(odd(s[t]));0015	       8 :0014		   begin0041		    t:=t-1; s[t]:=ord(s[t]=s[t+1]);0013		   end;0015	       9 :0014		   begin^^^^^^^^^^^^^^^^^^^0042		    t:=t-1; s[t]:=ord(s[t]<>s[t+1]);0013		   end;0016	       10 :0015		    begin0042		     t:=t-1; s[t]:=ord(s[t]<s[t+1]);0014		    end;0016	       11 :0015		    begin0043		     t:=t-1; s[t]:=ord(s[t]>=s[t+1]);0014		    end;0016	       12 :0015		    begin0042		     t:=t-1; s[t]:=ord(s[t]>s[t+1]);0014		    end;0016	       13 :0015		    begin0043		     t:=t-1; s[t]:=ord(s[t]<=s[t+1]);0014		    end;0015	      end;0010	lod :0016	      begin0039	       t:=t+1; s[t]:=s[base(l)+a];0015	      end;0010	sto :^^0016	      begin0039	       s[base(l)+a]:=s[t]; t:=t-1;0015	      end;0010	cal :0016	      begin0064	       s[t+1]:=base(l); s[t+2]:=b; s[t+3]:=p; b:=t+1; p:=a;0015	      end;0018	int : t:=t+a;0016	jmp : p:=a;0010	jpc :0016	      begin0021	       if s[t]=00030	       then p:=a; t:=t-1;0015	      end;0010	wrt :0016	      begin0034	       writeln(s[t]); t:=t-1;0015	      end;0010	inp :0016	      begin0064	       t:=t+1; write(tty,'? '); break(tty); read(tty,s[t]);0015	      end;0015       end;^^^^^^^^^^^^^^^^0019     until p=0;0016    writeln;0042    writeln('End of interpretation.');0011   end;00040010 begin0019  writeln(tty);0056  writeln(tty,'PL/0 - Poor Man',chr(39),'s Pascal');0019  writeln(tty);0050  for ch:=chr(0) to chr(255) do ssym[ch]:=nul;0074  word[1]:='BEGIN     '; word[2]:='CALL      '; word[3]:='CONST     ';0074  word[4]:='DO        '; word[5]:='END       '; word[6]:='IF        ';0074  word[7]:='ODD       '; word[8]:='PROCEDURE '; word[9]:='READ      ';^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^0077  word[10]:='THEN      '; word[11]:='VAR       '; word[12]:='WHILE     ';0029  word[13]:='WRITE     ';0077  wsym[1]:=beginsym; wsym[2]:=callsym; wsym[3]:=constsym; wsym[4]:=dosym;0073  wsym[5]:=endsym; wsym[6]:=ifsym; wsym[7]:=oddsym; wsym[8]:=procsym;0080  wsym[9]:=readsym; wsym[10]:=thensym; wsym[11]:=varsym; wsym[12]:=whilesym;0025  wsym[13]:=writesym;0076  ssym['+']:=plus; ssym['-']:=minus; ssym['*']:=times; ssym['/']:=slash;0075  ssym['(']:=lparen; ssym[')']:=rparen; ssym['=']:=eql; ssym['#']:=neq;0074  ssym[',']:=comma; ssym['.']:=period; ssym['<']:=lss; ssym['{']:=leq;0059  ssym['>']:=gtr; ssym['}']:=geq; ssym[';']:=semicolon;0077  mn[lit]:='LIT  '; mn[opr]:='OPR  '; mn[lod]:='LOD  '; mn[sto]:='STO  ';0077  mn[cal]:='CAL  '; mn[int]:='INT  '; mn[jmp]:='JMP  '; mn[jpc]:='JPC  ';0041  mn[wrt]:='WRT  '; mn[inp]:='INP  ';0049  write(tty,'Input filename > '); break(tty);0018  readln(tty);0025  read(tty,filename);0028  reset(input,filename);0019  if eof(input)0010  then0012   begin0021    writeln(tty);^^0051    writeln(tty,'**** Error opening file ****')0010   end0010  else0012   begin0018    page(tty);0046    declbegsys:=[constsym,varsym,procsym];0063    statbegsys:=[beginsym,callsym,ifsym,whilesym,writesym];0041    facbegsys:=[ident,number,lparen];0053    cx:=0; cc:=0; ll:=0; ch:=' '; kk:=al; getsym;0050    block(0,0,[period]+declbegsys+statbegsys);0022    if sym<>period0022    then error(9);0016    if err=00022    then interpret0044    else writeln(tty,'Errors detected');0021    writeln(tty);0011   end;0009 end.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^