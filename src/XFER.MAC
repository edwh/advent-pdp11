	.TITLE	XFER - Terminal Hex File Transfer
	.IDENT	/V1.1/
;
;	XFER - Receive hex-encoded files via terminal
;
;	Protocol:
;	  :filename.ext     - Start receiving file
;	  :0000:HHHH...HH   - Line with hex data (line number ignored)
;	  :END              - End of file
;
;	Responds with OK or ERR after each line
;	On :END, outputs DONE:nnnn where nnnn is total byte count
;
;	Uses RT-11 programmed requests for file I/O
;	For RT-11/RSTS compatibility mode
;
;	Edward Hibbert, December 2025
;
; RT-11 Programmed Requests (EMT 375):
;   Code 1 (.FETCH) - Load handler
;   Code 2 (.RELEASE) - Release handler
;   Code 3 (.LOOKUP) - Open existing file for input
;   Code 4 (.ENTER) - Create/open file for output
;   Code 6 (.CLOSE) - Close file
;   Code 10 (.READ) - Read from file
;   Code 11 (.WRITE) - Write to file
;   Code 24 (.WRITW) - Write and wait
;
; Terminal I/O:
;   EMT 340 = .TTYIN  (read char into R0)
;   EMT 341 = .TTYOUT (write char from R0)
;   EMT 350 = .EXIT

	.ASECT
	.=1000			; Start at 1000 octal

START:	MOV	#HELLO,R0
	JSR	PC,PUTS		; Print hello message
	CLR	TOTBYT		; Clear total bytes
	CLR	TOTBYT+2	; (high word)

WAIT:	MOV	#MSGLP,R0	; Debug: print "LP"
	JSR	PC,PUTS
	JSR	PC,GETLIN	; Get a line
	TSTB	LINBUF		; Empty line?
	BEQ	WAIT		; Yes, ignore
	CMPB	LINBUF,#':	; Starts with colon?
	BNE	WAIT		; No, ignore

	; Check for :END
	CMPB	LINBUF+1,#'E
	BNE	NOTEND
	CMPB	LINBUF+2,#'N
	BNE	NOTEND
	CMPB	LINBUF+3,#'D
	BNE	NOTEND

	; End of file - close and report
	TST	FILCHN		; File open?
	BEQ	NOFILE		; No file
	JSR	PC,CLSFIL	; Close file
	; Print DONE:nnnn
	MOV	#MSGDON,R0
	JSR	PC,PUTSTR	; Print "DONE:" without CRLF
	MOV	TOTBYT,R0
	JSR	PC,PUTHEX4	; Print hex count
	JSR	PC,PUTCRLF
	CLR	TOTBYT
	BR	WAIT

NOFILE:	MOV	#MSGERR,R0
	JSR	PC,PUTS
	BR	WAIT

NOTEND:	; Check if it's a filename (no second colon = filename)
	MOV	#MSGN1,R0	; Debug: print "N1"
	JSR	PC,PUTS
	MOV	#LINBUF+1,R0
	JSR	PC,FNDCOL	; Find second colon
	MOV	#MSGN2,R0	; Debug: print "N2"
	JSR	PC,PUTS
	TST	R0		; Found colon?
	BNE	ISDATA		; Yes, it's data

	; It's a filename - open new file
	TST	FILCHN		; Already have file open?
	BEQ	10$
	JSR	PC,CLSFIL	; Close it first
10$:	MOV	#MSGDBG,R0	; Debug: print "DBG"
	JSR	PC,PUTS
	JSR	PC,OPNFIL	; Open new file
	TST	R0		; Success?
	BNE	20$
	MOV	#MSGOK,R0	; Yes
	BR	30$
20$:	MOV	#MSGERR,R0	; No
30$:	JSR	PC,PUTS
	BR	WAIT

ISDATA:	; It's hex data - decode and write
	; R0 points to first char after second colon
	MOV	R0,R1		; Save position
	; Skip 4 hex digits of line number and the colon after
	ADD	#5,R1		; Skip NNNN:
	CLR	BYTCNT		; Reset byte count
	MOV	#BINBUF,R2	; Output pointer

40$:	MOVB	(R1)+,R3	; Get first hex char
	BEQ	50$		; End of line
	CMPB	R3,#15		; CR?
	BEQ	50$
	CMPB	R3,#12		; LF?
	BEQ	50$
	CMPB	R3,#':		; Another colon (checksum)?
	BEQ	50$		; Stop before checksum
	JSR	PC,HEXDIG	; Convert to nibble in R0
	ASL	R0		; Shift to high nibble
	ASL	R0
	ASL	R0
	ASL	R0
	MOV	R0,R4		; Save high nibble
	MOVB	(R1)+,R3	; Get second hex char
	BEQ	50$		; Unexpected end
	JSR	PC,HEXDIG	; Convert to nibble
	BIS	R4,R0		; Combine nibbles
	MOVB	R0,(R2)+	; Store byte
	INC	BYTCNT		; Count it
	BR	40$		; Next byte

50$:	; Write buffer to file
	TST	FILCHN		; File open?
	BEQ	60$		; No, error
	TST	BYTCNT		; Any bytes?
	BEQ	55$		; No, just ack
	; Add to total
	ADD	BYTCNT,TOTBYT
	ADC	TOTBYT+2
	; Write to file
	JSR	PC,WRTFIL	; Write to file
	TST	R0		; Success?
	BNE	60$		; No
55$:	MOV	#MSGOK,R0
	BR	70$
60$:	MOV	#MSGERR,R0
70$:	JSR	PC,PUTS
	JMP	WAIT

; ============== Subroutines ==============

; HEXDIG - Convert hex character in R3 to value in R0
HEXDIG:	CLR	R0
	CMPB	R3,#'9		; Digit?
	BGT	HX1
	MOVB	R3,R0
	SUB	#'0,R0		; 0-9
	RTS	PC
HX1:	CMPB	R3,#'F		; Upper A-F?
	BGT	HX2
	MOVB	R3,R0
	SUB	#67,R0		; 'A' - 10 = 55
	RTS	PC
HX2:	MOVB	R3,R0		; Lower a-f
	SUB	#127,R0		; 'a' - 10 = 87
	RTS	PC

; FNDCOL - Find colon in string at R0, return ptr after colon or 0
FNDCOL:	MOV	R0,R1
FC1:	MOVB	(R1)+,R0
	BEQ	FC2		; End of string
	CMPB	R0,#':		; Colon?
	BEQ	FC3
	CMPB	R0,#15		; CR?
	BEQ	FC2
	CMPB	R0,#12		; LF?
	BNE	FC1
FC2:	CLR	R0		; Not found
	RTS	PC
FC3:	MOV	R1,R0		; Return pointer after colon
	RTS	PC

; PUTS - Print null-terminated string at R0, add CRLF
PUTS:	MOV	R0,R1
PT1:	MOVB	(R1)+,R0
	BEQ	PT2
	JSR	PC,PUTC
	BR	PT1
PT2:	JSR	PC,PUTCRLF
	RTS	PC

; PUTSTR - Print null-terminated string at R0, NO CRLF
PUTSTR:	MOV	R0,R1
PS1:	MOVB	(R1)+,R0
	BEQ	PS2
	JSR	PC,PUTC
	BR	PS1
PS2:	RTS	PC

; PUTCRLF - Output CR LF
PUTCRLF:
	MOV	#15,R0		; CR
	JSR	PC,PUTC
	MOV	#12,R0		; LF
	JSR	PC,PUTC
	RTS	PC

; PUTHEX4 - Output R0 as 4 hex digits
PUTHEX4:
	MOV	R0,-(SP)	; Save value
	MOV	R0,R1
	SWAB	R1		; Get high byte
	MOV	R1,R0
	JSR	PC,PHEX2	; Print high byte
	MOV	(SP)+,R0	; Restore
	; Fall through for low byte

; PHEX2 - Output low byte of R0 as 2 hex digits
PHEX2:	MOV	R0,-(SP)	; Save value
	ASR	R0		; Get high nibble
	ASR	R0
	ASR	R0
	ASR	R0
	BIC	#177760,R0	; Mask to 4 bits
	JSR	PC,PNIB
	MOV	(SP)+,R0
	BIC	#177760,R0	; Mask to 4 bits
	; Fall through

; PNIB - Output nibble (0-15) in R0 as hex char
PNIB:	CMP	R0,#9
	BGT	PN1
	ADD	#'0,R0
	BR	PN2
PN1:	ADD	#67,R0		; 'A' - 10 + 10 = 'A'
PN2:	JSR	PC,PUTC
	RTS	PC

; PUTC - Output character in R0
PUTC:	EMT	341		; .TTYOUT
	RTS	PC

; GETLIN - Read line into LINBUF (until CR or LF)
GETLIN:	MOV	#LINBUF,R1
	MOV	#80.,R2		; Max chars
GL1:	EMT	340		; .TTYIN - char in R0
	MOVB	R0,(R1)+
	CMPB	R0,#15		; CR?
	BEQ	GL2
	CMPB	R0,#12		; LF?
	BEQ	GL2
	SOB	R2,GL1		; Continue if room
GL2:	CLRB	(R1)		; Null terminate
	RTS	PC

; ============== File I/O ==============

; OPNFIL - Pretend to open file (for protocol testing)
; Filename in LINBUF+1 (after colon)
; Returns 0 in R0 (always succeeds for now)
OPNFIL:
	MOV	#1,FILCHN	; Mark file as open
	CLR	BLKNUM
	CLR	BUFPTR
	CLR	R0		; Success
	RTS	PC

; WRTFIL - Pretend to write file (for protocol testing)
; Returns 0 in R0 (always succeeds)
WRTFIL:
	CLR	R0		; Success
	RTS	PC

; CLSFIL - Close the file
CLSFIL:
	CLR	FILCHN
	CLR	BLKNUM
	CLR	BUFPTR
	CLR	R0
	RTS	PC

; ============== Data ==============

HELLO:	.ASCII	/XFER V1.1 Ready/
	.BYTE	0
	.EVEN
MSGOK:	.ASCII	/OK/
	.BYTE	0
	.EVEN
MSGERR:	.ASCII	/ERR/
	.BYTE	0
	.EVEN
MSGDON:	.ASCII	/DONE:/
	.BYTE	0
	.EVEN
MSGDBG:	.ASCII	/DBG/
	.BYTE	0
	.EVEN
MSGLP:	.ASCII	/LP/
	.BYTE	0
	.EVEN
MSGN1:	.ASCII	/N1/
	.BYTE	0
	.EVEN
MSGN2:	.ASCII	/N2/
	.BYTE	0
	.EVEN

LINBUF:	.BLKB	82.		; Input line buffer
BINBUF:	.BLKB	256.		; Hex decode buffer
BYTCNT:	.WORD	0		; Bytes in decode buffer
TOTBYT:	.BLKW	2		; Total bytes received
FILCHN:	.WORD	0		; File channel (0=none)
BLKNUM:	.WORD	0		; Current block number
BUFPTR:	.WORD	0		; Position in work buffer

	.END	START
