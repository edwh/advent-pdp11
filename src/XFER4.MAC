	.TITLE	XFER4 - Hex File Transfer with File I/O
	.IDENT	/V1.0/
;
;	XFER4 - Receive hex-encoded files and write to disk
;	Based on working XFER3 with added RT-11 file I/O
;
;	Protocol:
;	  :filename     - Start receiving file
;	  :0000:HH...   - Hex data line
;	  :END          - End of file
;
;	RT-11 Programmed Requests:
;	  .ENTER (create file) - EMT 375, code 4
;	  .WRITW (write wait)  - EMT 375, code 30
;	  .CLOSE (close file)  - EMT 375, code 6
;
;	Terminal I/O:
;	  EMT 340 = .TTYIN, EMT 341 = .TTYOUT, EMT 350 = .EXIT

	.ASECT
	.=1000

START:	MOV	#HELLO,R1
	JSR	PC,PUTS
	CLR	TOTBYT
	CLR	FILCHN
	CLR	BLKNUM
	CLR	BUFIDX

; Main loop
WAIT:	JSR	PC,GETLIN	; Get a line
	TSTB	LINBUF		; Empty?
	BEQ	WAIT
	CMPB	LINBUF,#':	; Starts with ':'?
	BNE	WAIT

	; Check for :END
	CMPB	LINBUF+1,#'E
	BNE	NOTEND
	CMPB	LINBUF+2,#'N
	BNE	NOTEND
	CMPB	LINBUF+3,#'D
	BNE	NOTEND

	; It's :END - flush buffer, close and report
	TST	FILCHN
	BEQ	NOFIL
	; Flush partial block if any
	TST	BUFIDX
	BEQ	10$
	JSR	PC,WRTBLK
10$:	JSR	PC,CLSFIL
	CLR	FILCHN
	; Print DONE:count
	MOV	#MSGDON,R1
	JSR	PC,PUTS2	; No CRLF
	MOV	TOTBYT,R0
	JSR	PC,PRHEX4
	MOV	#15,R0
	EMT	341
	MOV	#12,R0
	EMT	341
	CLR	TOTBYT
	BR	WAIT

NOFIL:	MOV	#MSGERR,R1
	JSR	PC,PUTS
	BR	WAIT

NOTEND:	; Check for second colon (data line)
	MOV	#LINBUF+1,R0
	JSR	PC,FNDCOL
	TST	R0
	BNE	ISDATA

	; No second colon = filename - open file
	JSR	PC,OPNFIL
	TST	R0
	BEQ	OPNOK
	MOV	#MSGERR,R1
	JSR	PC,PUTS
	BR	WAIT
OPNOK:	MOV	#1,FILCHN
	CLR	TOTBYT
	CLR	BLKNUM
	CLR	BUFIDX
	MOV	#MSGOK,R1
	JSR	PC,PUTS
	BR	WAIT

ISDATA:	; Hex data line
	TST	FILCHN
	BEQ	NODAT
	; R0 points after second colon
	; Skip 4 hex digits + colon (line number)
	ADD	#5,R0
	MOV	R0,R1		; R1 = pointer to hex data
	CLR	R4		; Byte count this line

NXTBYT:	MOVB	(R1)+,R2	; Get high nibble char
	BEQ	DONDAT
	CMPB	R2,#15		; CR?
	BEQ	DONDAT
	CMPB	R2,#12		; LF?
	BEQ	DONDAT
	CMPB	R2,#':		; Checksum separator?
	BEQ	DONDAT
	JSR	PC,HEXDIG	; Convert to nibble in R0
	ASL	R0
	ASL	R0
	ASL	R0
	ASL	R0
	MOV	R0,R3		; Save high nibble
	MOVB	(R1)+,R2	; Get low nibble char
	BEQ	DONDAT
	JSR	PC,HEXDIG
	BIS	R3,R0		; Combine
	; Store byte in block buffer
	MOV	BUFIDX,R5
	MOVB	R0,BLKBUF(R5)
	INC	BUFIDX
	INC	R4
	; Check if block full (512 bytes = 1000 octal)
	CMP	BUFIDX,#1000
	BLT	NXTBYT
	; Block full - write it
	JSR	PC,WRTBLK
	CLR	BUFIDX
	BR	NXTBYT

DONDAT:	ADD	R4,TOTBYT
	MOV	#MSGOK,R1
	JSR	PC,PUTS
	JMP	WAIT

NODAT:	MOV	#MSGERR,R1
	JSR	PC,PUTS
	JMP	WAIT

; ============ File I/O Subroutines ============

; OPNFIL - Open/create file for output
; Uses filename from LINBUF+1 (after colon)
; Returns 0 in R0 on success, non-zero on error
OPNFIL:
	; For now, use fixed filename XDATA.BIN
	; Copy to RAD50 format in FILBLK
	; RAD50: XDAT = 66424 octal, A<sp><sp> = 200 octal
	;        BIN  = 6766 octal, <sp><sp><sp> = 0
	MOV	#66424,FILBLK	; "XDAT"
	MOV	#200,FILBLK+2	; "A  "
	MOV	#6766,FILBLK+4	; "BIN"
	CLR	FILBLK+6	; "   "

	; Set up .ENTER arguments in CHNARA
	; Format: chan, devhdlr, filename, size
	CLR	CHNARA		; Channel 0
	CLR	CHNARA+2	; Default device DK:
	MOV	#FILBLK,CHNARA+4 ; Filename block
	MOV	#144,CHNARA+6	; 100 blocks (144 octal)

	; Call .ENTER (EMT 344)
	MOV	#CHNARA,R0
	EMT	344		; .ENTER
	BCS	OPNERR
	CLR	R0		; Success
	RTS	PC
OPNERR:	MOV	#1,R0		; Error
	RTS	PC

; WRTBLK - Write current block to file
; Uses BLKBUF, BUFIDX, BLKNUM
WRTBLK:
	; Set up .WRITW arguments
	; Format: chan, buffer, wordcount, block
	CLR	CHNARA		; Channel 0
	MOV	#BLKBUF,CHNARA+2 ; Buffer address
	MOV	BUFIDX,CHNARA+4	; Byte count
	INC	CHNARA+4	; Round up
	ASR	CHNARA+4	; Convert to word count
	MOV	BLKNUM,CHNARA+6	; Block number

	; Call .WRITW (EMT 351)
	MOV	#CHNARA,R0
	EMT	351		; .WRITW
	BCS	WRTERR
	INC	BLKNUM		; Next block
	CLR	R0		; Success
	RTS	PC
WRTERR:	MOV	#1,R0		; Error
	RTS	PC

; CLSFIL - Close the file
CLSFIL:
	CLR	CHNARA		; Channel 0

	; Call .CLOSE (EMT 346)
	MOV	#CHNARA,R0
	EMT	346		; .CLOSE
	CLR	BLKNUM
	CLR	BUFIDX
	RTS	PC

; ============ Utility Subroutines ============

; HEXDIG - Convert hex char in R2 to nibble in R0
HEXDIG:	CLR	R0
	CMPB	R2,#'9
	BGT	HX1
	MOVB	R2,R0
	SUB	#'0,R0
	RTS	PC
HX1:	CMPB	R2,#'F
	BGT	HX2
	MOVB	R2,R0
	SUB	#67,R0		; 'A'-10 = 55 = 67 octal
	RTS	PC
HX2:	MOVB	R2,R0
	SUB	#127,R0		; 'a'-10 = 87 = 127 octal
	RTS	PC

; FNDCOL - Find ':' in string at R0, return ptr after or 0
FNDCOL:	MOV	R0,R1
FC1:	MOVB	(R1)+,R0
	BEQ	FC2
	CMPB	R0,#':
	BEQ	FC3
	CMPB	R0,#15		; CR
	BEQ	FC2
	CMPB	R0,#12		; LF
	BNE	FC1
FC2:	CLR	R0
	RTS	PC
FC3:	MOV	R1,R0
	RTS	PC

; PUTS - Print string at R1 with CRLF
PUTS:	MOVB	(R1)+,R0
	BEQ	PUTS2E
	EMT	341
	BR	PUTS
PUTS2E:	MOV	#15,R0
	EMT	341
	MOV	#12,R0
	EMT	341
	RTS	PC

; PUTS2 - Print string at R1, no CRLF
PUTS2:	MOVB	(R1)+,R0
	BEQ	PUTS2R
	EMT	341
	BR	PUTS2
PUTS2R:	RTS	PC

; PRHEX4 - Print R0 as 4 hex digits
PRHEX4:	MOV	R0,-(SP)
	MOV	R0,R1
	SWAB	R1
	MOV	R1,R0
	JSR	PC,PRHEX2
	MOV	(SP)+,R0
	; Fall through

; PRHEX2 - Print low byte of R0 as 2 hex digits
PRHEX2:	MOV	R0,-(SP)
	ASR	R0
	ASR	R0
	ASR	R0
	ASR	R0
	BIC	#177760,R0
	JSR	PC,PRNIB
	MOV	(SP)+,R0
	BIC	#177760,R0
	; Fall through

; PRNIB - Print nibble in R0
PRNIB:	CMP	R0,#11		; 9 decimal = 11 octal
	BGT	PN1
	ADD	#'0,R0
	BR	PN2
PN1:	ADD	#67,R0		; 'A' - 10 = 55 = 67 octal
PN2:	EMT	341
	RTS	PC

; GETLIN - Read line into LINBUF
GETLIN:	MOV	#LINBUF,R1
	MOV	#120,R2		; 80 decimal
GL1:	EMT	340
	MOVB	R0,(R1)+
	CMPB	R0,#15
	BEQ	GL2
	CMPB	R0,#12
	BEQ	GL2
	SOB	R2,GL1
GL2:	CLRB	(R1)
	RTS	PC

; ============ Data ============

HELLO:	.ASCII	/XFER4 V1.0/
	.BYTE	0
MSGOK:	.ASCII	/OK/
	.BYTE	0
MSGERR:	.ASCII	/ERR/
	.BYTE	0
MSGDON:	.ASCII	/DONE:/
	.BYTE	0
	.EVEN

LINBUF:	.BLKB	82.		; Line input buffer
TOTBYT:	.WORD	0		; Total bytes received
FILCHN:	.WORD	0		; File channel flag
BLKNUM:	.WORD	0		; Current block number
BUFIDX:	.WORD	0		; Index into block buffer

; RT-11 file I/O areas
CHNARA:	.BLKW	4		; Channel area (8 bytes)
FILBLK:	.BLKW	4		; Filename block in RAD50
BLKBUF:	.BLKB	1000		; 512-byte block buffer

	.END	START
