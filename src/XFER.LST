       1                                	.TITLE	XFER - Terminal Hex File Transfer
       2                                	.IDENT	/V1.1/
       3                                ;
       4                                ;	XFER - Receive hex-encoded files via terminal
       5                                ;
       6                                ;	Protocol:
       7                                ;	  :filename.ext     - Start receiving file
       8                                ;	  :0000:HHHH...HH   - Line with hex data (line number ignored)
       9                                ;	  :END              - End of file
      10                                ;
      11                                ;	Responds with OK or ERR after each line
      12                                ;	On :END, outputs DONE:nnnn where nnnn is total byte count
      13                                ;
      14                                ;	Uses RT-11 programmed requests for file I/O
      15                                ;	For RT-11/RSTS compatibility mode
      16                                ;
      17                                ;	Edward Hibbert, December 2025
      18                                ;
      19                                ; RT-11 Programmed Requests (EMT 375):
      20                                ;   Code 1 (.FETCH) - Load handler
      21                                ;   Code 2 (.RELEASE) - Release handler
      22                                ;   Code 3 (.LOOKUP) - Open existing file for input
      23                                ;   Code 4 (.ENTER) - Create/open file for output
      24                                ;   Code 6 (.CLOSE) - Close file
      25                                ;   Code 10 (.READ) - Read from file
      26                                ;   Code 11 (.WRITE) - Write to file
      27                                ;   Code 24 (.WRITW) - Write and wait
      28                                ;
      29                                ; Terminal I/O:
      30                                ;   EMT 340 = .TTYIN  (read char into R0)
      31                                ;   EMT 341 = .TTYOUT (write char from R0)
      32                                ;   EMT 350 = .EXIT
      33                                
      34                                	.ASECT
      35 001000                         	.=1000			; Start at 1000 octal
      36                                
      37 001000 012700  002046          START:	MOV	#HELLO,R0
      38 001004 004767  001560'         	JSR	PC,PUTS		; Print hello message
      39 001010 005067  002650'         	CLR	TOTBYT		; Clear total bytes
      40 001014 005067  002652'         	CLR	TOTBYT+2	; (high word)
      41                                
      42 001020 012700  002110          WAIT:	MOV	#MSGLP,R0	; Debug: print "LP"
      43 001024 004767  001560'         	JSR	PC,PUTS
      44 001030 004767  001742'         	JSR	PC,GETLIN	; Get a line
      45 001034 105767  002124'         	TSTB	LINBUF		; Empty line?
      46 001040 001767                  	BEQ	WAIT		; Yes, ignore
      47 001042 126727  002124' 000072  	CMPB	LINBUF,#':	; Starts with colon?
      48 001050 001363                  	BNE	WAIT		; No, ignore
      49                                
      50                                	; Check for :END
      51 001052 126727  002125' 000105  	CMPB	LINBUF+1,#'E
      52 001060 001037                  	BNE	NOTEND
      53 001062 126727  002126' 000116  	CMPB	LINBUF+2,#'N
      54 001070 001033                  	BNE	NOTEND
      55 001072 126727  002127' 000104  	CMPB	LINBUF+3,#'D
      56 001100 001027                  	BNE	NOTEND
      57                                
      58                                	; End of file - close and report
      59 001102 005767  002654'         	TST	FILCHN		; File open?
      60 001106 001417                  	BEQ	NOFILE		; No file
      61 001110 004767  002026'         	JSR	PC,CLSFIL	; Close file
      62                                	; Print DONE:nnnn
      63 001114 012700  002076          	MOV	#MSGDON,R0
      64 001120 004767  001602'         	JSR	PC,PUTSTR	; Print "DONE:" without CRLF
      65 001124 016700  002650'         	MOV	TOTBYT,R0
      66 001130 004767  001642'         	JSR	PC,PUTHEX4	; Print hex count
      67 001134 004767  001620'         	JSR	PC,PUTCRLF
      68 001140 005067  002650'         	CLR	TOTBYT
      69 001144 000725                  	BR	WAIT
      70                                
      71 001146 012700  002072          NOFILE:	MOV	#MSGERR,R0
      72 001152 004767  001560'         	JSR	PC,PUTS
      73 001156 000720                  	BR	WAIT
      74                                
      75                                NOTEND:	; Check if it's a filename (no second colon = filename)
      76 001160 012700  002114          	MOV	#MSGN1,R0	; Debug: print "N1"
      77 001164 004767  001560'         	JSR	PC,PUTS
      78 001170 012700  002125          	MOV	#LINBUF+1,R0
      79 001174 004767  001520'         	JSR	PC,FNDCOL	; Find second colon
      80 001200 012700  002120          	MOV	#MSGN2,R0	; Debug: print "N2"
      81 001204 004767  001560'         	JSR	PC,PUTS
      82 001210 005700                  	TST	R0		; Found colon?
      83 001212 001025                  	BNE	ISDATA		; Yes, it's data
      84                                
      85                                	; It's a filename - open new file
      86 001214 005767  002654'         	TST	FILCHN		; Already have file open?
      87 001220 001402                  	BEQ	10$
      88 001222 004767  002026'         	JSR	PC,CLSFIL	; Close it first
      89 001226 012700  002104          10$:	MOV	#MSGDBG,R0	; Debug: print "DBG"
      90 001232 004767  001560'         	JSR	PC,PUTS
      91 001236 004767  002000'         	JSR	PC,OPNFIL	; Open new file
      92 001242 005700                  	TST	R0		; Success?
      93 001244 001003                  	BNE	20$
      94 001246 012700  002066          	MOV	#MSGOK,R0	; Yes
      95 001252 000402                  	BR	30$
      96 001254 012700  002072          20$:	MOV	#MSGERR,R0	; No
      97 001260 004767  001560'         30$:	JSR	PC,PUTS
      98 001264 000655                  	BR	WAIT
      99                                
     100                                ISDATA:	; It's hex data - decode and write
     101                                	; R0 points to first char after second colon
     102 001266 010001                  	MOV	R0,R1		; Save position
     103                                	; Skip 4 hex digits of line number and the colon after
     104 001270 062701  000005          	ADD	#5,R1		; Skip NNNN:
     105 001274 005067  002646'         	CLR	BYTCNT		; Reset byte count
     106 001300 012702  002246          	MOV	#BINBUF,R2	; Output pointer
     107                                
     108 001304 112103                  40$:	MOVB	(R1)+,R3	; Get first hex char
     109 001306 001431                  	BEQ	50$		; End of line
     110 001310 120327  000015          	CMPB	R3,#15		; CR?
     111 001314 001426                  	BEQ	50$
     112 001316 120327  000012          	CMPB	R3,#12		; LF?
     113 001322 001423                  	BEQ	50$
     114 001324 120327  000072          	CMPB	R3,#':		; Another colon (checksum)?
     115 001330 001420                  	BEQ	50$		; Stop before checksum
     116 001332 004767  001452'         	JSR	PC,HEXDIG	; Convert to nibble in R0
     117 001336 006300                  	ASL	R0		; Shift to high nibble
     118 001340 006300                  	ASL	R0
     119 001342 006300                  	ASL	R0
     120 001344 006300                  	ASL	R0
     121 001346 010004                  	MOV	R0,R4		; Save high nibble
     122 001350 112103                  	MOVB	(R1)+,R3	; Get second hex char
     123 001352 001407                  	BEQ	50$		; Unexpected end
     124 001354 004767  001452'         	JSR	PC,HEXDIG	; Convert to nibble
     125 001360 050400                  	BIS	R4,R0		; Combine nibbles
     126 001362 110022                  	MOVB	R0,(R2)+	; Store byte
     127 001364 005267  002646'         	INC	BYTCNT		; Count it
     128 001370 000745                  	BR	40$		; Next byte
     129                                
     130                                50$:	; Write buffer to file
     131 001372 005767  002654'         	TST	FILCHN		; File open?
     132 001376 001417                  	BEQ	60$		; No, error
     133 001400 005767  002646'         	TST	BYTCNT		; Any bytes?
     134 001404 001411                  	BEQ	55$		; No, just ack
     135                                	; Add to total
     136 001406 066767  002646' 002650' 	ADD	BYTCNT,TOTBYT
     137 001414 005567  002652'         	ADC	TOTBYT+2
     138                                	; Write to file
     139 001420 004767  002022'         	JSR	PC,WRTFIL	; Write to file
     140 001424 005700                  	TST	R0		; Success?
     141 001426 001003                  	BNE	60$		; No
     142 001430 012700  002066          55$:	MOV	#MSGOK,R0
     143 001434 000402                  	BR	70$
     144 001436 012700  002072          60$:	MOV	#MSGERR,R0
     145 001442 004767  001560'         70$:	JSR	PC,PUTS
     146 001446 000167  001020'         	JMP	WAIT
     147                                
     148                                ; ============== Subroutines ==============
     149                                
     150                                ; HEXDIG - Convert hex character in R3 to value in R0
     151 001452 005000                  HEXDIG:	CLR	R0
     152 001454 120327  000071          	CMPB	R3,#'9		; Digit?
     153 001460 003004                  	BGT	HX1
     154 001462 110300                  	MOVB	R3,R0
     155 001464 162700  000060          	SUB	#'0,R0		; 0-9
     156 001470 000207                  	RTS	PC
     157 001472 120327  000106          HX1:	CMPB	R3,#'F		; Upper A-F?
     158 001476 003004                  	BGT	HX2
     159 001500 110300                  	MOVB	R3,R0
     160 001502 162700  000067          	SUB	#67,R0		; 'A' - 10 = 55
     161 001506 000207                  	RTS	PC
     162 001510 110300                  HX2:	MOVB	R3,R0		; Lower a-f
     163 001512 162700  000127          	SUB	#127,R0		; 'a' - 10 = 87
     164 001516 000207                  	RTS	PC
     165                                
     166                                ; FNDCOL - Find colon in string at R0, return ptr after colon or 0
     167 001520 010001                  FNDCOL:	MOV	R0,R1
     168 001522 112100                  FC1:	MOVB	(R1)+,R0
     169 001524 001411                  	BEQ	FC2		; End of string
     170 001526 120027  000072          	CMPB	R0,#':		; Colon?
     171 001532 001410                  	BEQ	FC3
     172 001534 120027  000015          	CMPB	R0,#15		; CR?
     173 001540 001403                  	BEQ	FC2
     174 001542 120027  000012          	CMPB	R0,#12		; LF?
     175 001546 001365                  	BNE	FC1
     176 001550 005000                  FC2:	CLR	R0		; Not found
     177 001552 000207                  	RTS	PC
     178 001554 010100                  FC3:	MOV	R1,R0		; Return pointer after colon
     179 001556 000207                  	RTS	PC
     180                                
     181                                ; PUTS - Print null-terminated string at R0, add CRLF
     182 001560 010001                  PUTS:	MOV	R0,R1
     183 001562 112100                  PT1:	MOVB	(R1)+,R0
     184 001564 001403                  	BEQ	PT2
     185 001566 004767  001736'         	JSR	PC,PUTC
     186 001572 000773                  	BR	PT1
     187 001574 004767  001620'         PT2:	JSR	PC,PUTCRLF
     188 001600 000207                  	RTS	PC
     189                                
     190                                ; PUTSTR - Print null-terminated string at R0, NO CRLF
     191 001602 010001                  PUTSTR:	MOV	R0,R1
     192 001604 112100                  PS1:	MOVB	(R1)+,R0
     193 001606 001403                  	BEQ	PS2
     194 001610 004767  001736'         	JSR	PC,PUTC
     195 001614 000773                  	BR	PS1
     196 001616 000207                  PS2:	RTS	PC
     197                                
     198                                ; PUTCRLF - Output CR LF
     199                                PUTCRLF:
     200 001620 012700  000015          	MOV	#15,R0		; CR
     201 001624 004767  001736'         	JSR	PC,PUTC
     202 001630 012700  000012          	MOV	#12,R0		; LF
     203 001634 004767  001736'         	JSR	PC,PUTC
     204 001640 000207                  	RTS	PC
     205                                
     206                                ; PUTHEX4 - Output R0 as 4 hex digits
     207                                PUTHEX4:
     208 001642 010046                  	MOV	R0,-(SP)	; Save value
     209 001644 010001                  	MOV	R0,R1
     210 001646 000301                  	SWAB	R1		; Get high byte
     211 001650 010100                  	MOV	R1,R0
     212 001652 004767  001660'         	JSR	PC,PHEX2	; Print high byte
     213 001656 012600                  	MOV	(SP)+,R0	; Restore
     214                                	; Fall through for low byte
     215                                
     216                                ; PHEX2 - Output low byte of R0 as 2 hex digits
     217 001660 010046                  PHEX2:	MOV	R0,-(SP)	; Save value
     218 001662 006200                  	ASR	R0		; Get high nibble
     219 001664 006200                  	ASR	R0
     220 001666 006200                  	ASR	R0
     221 001670 006200                  	ASR	R0
     222 001672 042700  177760          	BIC	#177760,R0	; Mask to 4 bits
     223 001676 004767  001710'         	JSR	PC,PNIB
     224 001702 012600                  	MOV	(SP)+,R0
     225 001704 042700  177760          	BIC	#177760,R0	; Mask to 4 bits
     226                                	; Fall through
     227                                
     228                                ; PNIB - Output nibble (0-15) in R0 as hex char
     229 001710 020027  000000          PNIB:	CMP	R0,#9
     230 001714 003003                  	BGT	PN1
     231 001716 062700  000060          	ADD	#'0,R0
     232 001722 000402                  	BR	PN2
     233 001724 062700  000067          PN1:	ADD	#67,R0		; 'A' - 10 + 10 = 'A'
     234 001730 004767  001736'         PN2:	JSR	PC,PUTC
     235 001734 000207                  	RTS	PC
     236                                
     237                                ; PUTC - Output character in R0
     238 001736 104341                  PUTC:	EMT	341		; .TTYOUT
     239 001740 000207                  	RTS	PC
     240                                
     241                                ; GETLIN - Read line into LINBUF (until CR or LF)
     242 001742 012701  002124          GETLIN:	MOV	#LINBUF,R1
     243 001746 012702  000120          	MOV	#80.,R2		; Max chars
     244 001752 104340                  GL1:	EMT	340		; .TTYIN - char in R0
     245 001754 110021                  	MOVB	R0,(R1)+
     246 001756 120027  000015          	CMPB	R0,#15		; CR?
     247 001762 001404                  	BEQ	GL2
     248 001764 120027  000012          	CMPB	R0,#12		; LF?
     249 001770 001401                  	BEQ	GL2
     250 001772 077211                  	SOB	R2,GL1		; Continue if room
     251 001774 105011                  GL2:	CLRB	(R1)		; Null terminate
     252 001776 000207                  	RTS	PC
     253                                
     254                                ; ============== File I/O ==============
     255                                
     256                                ; OPNFIL - Pretend to open file (for protocol testing)
     257                                ; Filename in LINBUF+1 (after colon)
     258                                ; Returns 0 in R0 (always succeeds for now)
     259                                OPNFIL:
     260 002000 012767  000001  002654' 	MOV	#1,FILCHN	; Mark file as open
     261 002006 005067  002656'         	CLR	BLKNUM
     262 002012 005067  002660'         	CLR	BUFPTR
     263 002016 005000                  	CLR	R0		; Success
     264 002020 000207                  	RTS	PC
     265                                
     266                                ; WRTFIL - Pretend to write file (for protocol testing)
     267                                ; Returns 0 in R0 (always succeeds)
     268                                WRTFIL:
     269 002022 005000                  	CLR	R0		; Success
     270 002024 000207                  	RTS	PC
     271                                
     272                                ; CLSFIL - Close the file
     273                                CLSFIL:
     274 002026 005067  002654'         	CLR	FILCHN
     275 002032 005067  002656'         	CLR	BLKNUM
     276 002036 005067  002660'         	CLR	BUFPTR
     277 002042 005000                  	CLR	R0
     278 002044 000207                  	RTS	PC
     279                                
     280                                ; ============== Data ==============
     281                                
     282 002046    130     106     105  HELLO:	.ASCII	/XFER V1.1 Ready/
         002051    122     040     126  
         002054    061     056     061  
         002057    040     122     145  
         002062    141     144     171  
     283 002065    000                  	.BYTE	0
     284                                	.EVEN
     285 002066    117     113          MSGOK:	.ASCII	/OK/
     286 002070    000                  	.BYTE	0
     287 002071    000                  	.EVEN
     288 002072    105     122     122  MSGERR:	.ASCII	/ERR/
     289 002075    000                  	.BYTE	0
     290                                	.EVEN
     291 002076    104     117     116  MSGDON:	.ASCII	/DONE:/
         002101    105     072          
     292 002103    000                  	.BYTE	0
     293                                	.EVEN
     294 002104    104     102     107  MSGDBG:	.ASCII	/DBG/
     295 002107    000                  	.BYTE	0
     296                                	.EVEN
     297 002110    114     120          MSGLP:	.ASCII	/LP/
     298 002112    000                  	.BYTE	0
     299 002113    000                  	.EVEN
     300 002114    116     061          MSGN1:	.ASCII	/N1/
     301 002116    000                  	.BYTE	0
     302 002117    000                  	.EVEN
     303 002120    116     062          MSGN2:	.ASCII	/N2/
     304 002122    000                  	.BYTE	0
     305 002123    000                  	.EVEN
     306                                
     307 002124                         LINBUF:	.BLKB	82.		; Input line buffer
     308 002246                         BINBUF:	.BLKB	256.		; Hex decode buffer
     309 002646 000000                  BYTCNT:	.WORD	0		; Bytes in decode buffer
     310 002650                         TOTBYT:	.BLKW	2		; Total bytes received
     311 002654 000000                  FILCHN:	.WORD	0		; File channel (0=none)
     312 002656 000000                  BLKNUM:	.WORD	0		; Current block number
     313 002660 000000                  BUFPTR:	.WORD	0		; Position in work buffer
     314                                
     315                                	.END	START
     315                                
