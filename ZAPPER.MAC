	.title	zapper
;
;	FAST job scheduler !
;
;	E.D.W. Hibbert 1987
;
;
;	Compilation :
;
;	MACRO ZAPPER,ZAPPER=PA:DEFS,DP1:[1,95]ZAPPER.MAC (or wherever)
;	(use MACRO rather than expected MAC as it is twice(!) as fast)
;	TKB ZAPPER=ZAPPER,PA:IOLIB/LB
;
;	If you want a CCL, then add one - make it come in at 2000
;
;
	$rsx
	$rwdef
	.list	ttm
	.nlist	bin

start:	clr	ccl
	tst	firqb+fqent		; CCL entry
	beq	20$
	tstb	corcom			; Any CCL arguments ?
	beq	20$

2$:	inc	r0
	cmpb	corcom(r0),#32.		; Skim
	beq	3$			; past
	cmpb	corcom(r0),#'/		; CCL
	beq	3$			; name.
	cmpb	r0,corcom
	ble	2$
	br	20$			; Go to print header etc.

3$:	inc	r0
	movb	corcom,r2		; Length
	mov	r2,r1
	sub	r0,r1

4$:	movb	corcom(r2),kbbuf(r1)
	dec	r1			; Copy the
	dec	r2			; arguments
	cmp	r2,r0			; ready for
	bge	4$			; deccmd
	inc	ccl			; set flag
	br	25$

20$:	.lmargin
	.newline
	.print	#header			; print program
	.errprt	#0			; and system headers

25$:	.stat				; check for
	clr	priv			; [1,*]
	bit	#177000,xrb+10
	bne	30$
	inc	priv

30$:	clr	job
	call	getdta
	mov	job,ownjob
	mov	kb,ownkb
	.newline
	.newline

doit:	cmp	ccl,#2
	bne	1$			; check whether it was a
	.newline			; CCL entry.  If so
	.exit				; then exit.

1$:	tst	ccl
	beq	2$
	inc	ccl

2$:	call	getcmd
	bcs	doit			; command error

	mov	#doit,@#24		; ^C trap
	tst	wntjob			; did they specify a job number ?
	beq	3$			; no
	mov	wntjob,job		; yes, so
	call	getdta			; get stats
	tstb	firqb			; error ?
	bne	doit			; yes, give up
	call	prtdta			; no, so show the job
	mov	comcal,r0		; prepare to do whatever they want
	call	(r0)			; do it
	br	doit			; ok, finished.

3$:	tst	wntppn			; did they specify a PPN ?
	beq	10$			; no
	mov	#1,job			; start scan at job 1

4$:	call	getdta
	cmpb	firqb,#10.		; no job with that number ?
	beq	9$			; no, try next job
	tstb	firqb			; end of job table
	bne	doit			; no, get next command
	cmp	ppn,wntppn		; does it obviously match ?
	bne	5$			; no, but may contain *
	call	prtdta
	mov	comcal,r0
	call	(r0)			; do whatever
	br	9$			; and check for others

5$:	cmpb	ppn,wntppn
	beq	6$
	cmpb	wntppn,#255.
	beq	6$			; check whether prog matches
	br	9$			; no

6$:	cmpb	ppn+1,wntppn+1
	beq	7$
	cmpb	wntppn+1,#255.
	beq	7$
	br	9$			; does proj match ?

7$:	call	prtdta
	mov	comcal,r0
	call	(r0)			; do whatever
	br	9$

9$:	inc	job
	br	4$			; try next

10$:	cmp	wntkb,#255.		; kb* ?
	beq	11$			; yes, deal with later
	calls	$zapfqb
	movb	#16.,firqb+fqfun
	movb	wntkb,firqb+5		; do set terminal characteristic
	.uuo				; call to find the owning job
	movb	firqb+4,job		; get the job number
	asr	job			; (not *2)
	call	getdta
	cmp	kb,wntkb		; is job controlling on that kb ?
	bne	13$
	call	prtdta
	mov	comcal,r0
	call	(r0)
	br	doit			; do whatever and end

13$:	cmp	com,#8.
	beq	14$
	cmp	com,#16.
	beq	14$
	br	doit			; logged out kb so only send & force

14$:	mov	wntkb,kb
	mov	comcal,r0
	call	(r0)
	jmp	doit			; do send or force

11$:	mov	#16.,kb			; start at kb16:, not at pks
12$:	cmp	kb,ownkb
	beq	15$
	cmp	kb,#28.			; don't do anything to
	beq	15$			; communications keyboards
	cmp	kb,#29.			; cos it starts inter-system
	beq	15$			; chatter which stalls system
	mov	comcal,r0
	call	(r0)
15$:	inc	kb
	cmp	kb,#50.
	ble	12$
	jmp	doit

kbbuf:	.blkw	256.
header:	.asciz	/ZAPPER /
priv:	.word	0
ownjob:	.word	0
ownkb:	.word	0
ccl:	.word	0

getcmd:	clr	@#24			; no ^C trap
	calls	$zapxrb
	movb	#2,xrb+7
	.spec
	tst	ccl
	bne	3$
	.lmargin
	.newline
	.print	#prompt
	.input	#kbbuf
	mov	by$cnt,r0
	clrb	kbbuf(r0)		; null terminator
	.lmargin
	.len	#kbbuf
	calls	cvt$$,<#kbbuf,r0,#36.>	; change to upper case
	clrb	kbbuf(r0)		; put null terminator

	ifnoerr	3$
	.exit				; ^Z so exit

3$:	.len	#kbbuf
	tst	r0			; any command ?
	bne	4$
	movb	#'S,commnd		; no, so default
	clrb	commnd+1
	mov	#"[*,arg1		; command is
	mov	#",*,arg1+2		; a status of
	movb	#'],arg1+4		; all jobs
	clrb	arg1+5
	clr	didprt
	br	5$

4$:	clr	argptr
	movb	#32.,argter		; look for space
	clrb	commnd
	clrb	arg1
	clrb	arg2
	clr	didprt
	mov	#commnd,r5
	call	getarg
	mov	#arg1,r5
	call	getarg
	clrb	argter			; now look for null
	mov	#arg2,r5
	call	getarg

5$:	call	deccmd			; is it a valid command ?
	bcc	6$
	movc	#commnd,#arg1,#20.	; no, try to do a status
	call	decarg			; of what they typed
	bcc	9$
	return

9$:	clr	r0
	br	6$

6$:	mov	comloc(r0),comcal	; save address of command routine
	mov	r0,com			; save number of command
	tst	priv			; if they're privileged
	bne	7$			; then they can do anything
	tst	r0			; if they're a pleb
	beq	7$			; then all then can do is a status
	sec				; they can't do what they want
	return

7$:	call	decarg			; find out the job spec
	bcc	8$			; no errors
	return				; not a valid job spec

8$:	clc				; they can do it
	return

commnd:	.blkw	20.
arg1:	.blkw	20.
arg2:	.blkw	256.
prompt:	.asciz	/Zapper >> /
	.even
com:	.word	0
comcal:	.word	0
comloc:	.word	status
	.word	prio
	.word	runb
	.word	kill
	.word	send
	.word	det
	.word	slow
	.word	susp
	.word	force

getarg:	mov	argptr,r4
	.len	#kbbuf
	cmp	r0,r4
	bgt	1$
	clrb	(r5)
	return

1$:	cmpb	kbbuf(r4),argter
	beq	2$
	movb	kbbuf(r4),(r5)+
	inc	r4
	cmp	r4,r0
	ble	1$
	clrb	(r5)
	mov	r0,argptr
	return				; Copy arg & check for end

2$:	inc	r4
	mov	r4,argptr
	clrb	(r5)
	return				; found a space

argptr:	.word	0
argter:	.byte	0
	.even

;	GETDTA
;
;
;	Passed : job number in JOB
;
;
;	Gets job data.  Perhaps change to PEEKS for real speed ?
;
getdta:	calls	$zapfqb
	movb	#uu.sys,firqb+fqfun
	movb	job,firqb+4
	.uuo
	movb	firqb+4,r1
	tst	firqb
	bne	1$
	movb	firqb+5,kb
	mov	firqb+10,cpu
	mov	firqb+22,name
	mov	firqb+24,name+2
	mov	firqb+26,ppn
	clr	contrl
	movb	firqb+6,r5
	tstb	firqb+6
	beq	2$
	movb	firqb+6,r1
	asr	r1
	mov	r1,contrl
2$:	calls	$zapfqb
	movb	#uu.sys,firqb+fqfun
	movb	job,firqb+4
	movb	#1,firqb+5
	.uuo
	asrb	firqb+4
	movb	firqb+4,job			; get the job number
	mov	firqb+12,jbstat			; use these three
	mov	firqb+14,jbwait			; later to find the
	mov	firqb+26,kbtmo			; job state.
	mov	firqb+22,prirun
1$:	return

job:	.word	0
contrl:	.word	0
kb:	.word	0
cpu:	.word	0
jbstat:	.word	0
jbwait:	.word	0
kbtmo:	.word	0
name:	.blkw	2
ppn:	.word	0
prirun:	.word	0

;	DECCMD
;
;
;	Decodes command.
;
;	Command returned in R0
;
;	Carry set if it was not valid
;
;
deccmd:	clr	r0
	clr	r1

1$:	tstb	commnd(r0)		; end of string ?
	beq	5$			; yes, therefore we found a match
	cmpb	comlst(r1),commnd(r0)
	bne	2$			; not this command, so try next
	inc	r0
	inc	r1
	br	1$			; check next character

2$:	clr	r0
	div	#8.,r0
	inc	r0
	mul	#8.,r0			; next command in list
	cmp	r1,#72.			; end of list ?
	bge	3$			; yes, therefore no match found
	clr	r0
	br	1$			; try this command

3$:	sec				; no match found
	return

5$:	clr	r0
	div	#8.,r0
	mul	#2.,r0			; get command number
	mov	r1,r0			; and put in r0
	clc				; no errors
	return

comlst:	.ascii	/STATUS/<0><0>
	.ascii	/PRIORITY/
	.ascii	/RUNBURST/
	.ascii	/KILL/<0><0><0><0>
	.ascii	/SEND/<0><0><0><0>
	.ascii	/DETACH/<0><0>
	.ascii	/SLOW/<0><0><0><0>
	.ascii	/SUSPEND/<0>
	.ascii	/FORCE/<0><0><0>

decarg:	clr	wntjob
	clr	wntkb
	clr	wntppn
	.val	#arg1,#20.,wntjob		; job number ?
	iferr	1$				; no
	tst	wntjob
	bne	6$
	mov	ownjob,wntjob			; do this job
6$:	clc					; no errors
	return

1$:	cmpb	arg1,#'K			; K or KB ?
	bne	4$				; no
	mov	#arg1+1,r1
	cmpb	(r1),#'B
	bne	2$				; K something
	inc	r1				; KB so do VAL 1 char later

2$:	clr	er$sav
	.val	r1,#2.,wntkb
	iferr	3$				; not number but could be *
	clc					; no errors
	return

3$:	cmpb	(r1),#'*			; kb* ?
	bne	4$				; no
	movb	#255.,wntkb			; yes, set flag
	clc					; no errors
	return

4$:	calls	$zapfqb				; last chance is account
	.len	#arg1
	mov	r0,xrb+xrlen
	mov	r0,xrb+xrbc
	mov	#arg1,xrb+xrloc
	clr	xrb+10
	.fss					; so do filename string scan
	tstb	firqb				; error ?
	bne	5$				; yes
	bit	#200,xrb+10			; PPN specified ?
	beq	5$				; no
	mov	firqb+fqppn,wntppn		; yes, so save PPN
	clc					; no errors
	return

5$:	.newline
	.print	#accerr				; Not a valid job spec
	sec					; so set flag
	return

wntjob:	.word	0
wntkb:	.word	0
wntppn:	.word	0
accerr:	.asciz	/?Not a valid account./<13.><10.>

prtdta:	tst	didprt				; have we printed the header ?
	bne	1$				; yes, skip it
	.print	#dtahed				; print header
	inc	didprt				; and set flag

1$:	movc	#linfrm,#out,#55.
	calls	l$cvtnum,<#out,job,#2>		; do job number
	tst	ppn				; logged out ?
	beq	4$
	clr	r5
	bisb	ppn+1,r5
	calls	l$cvtnum,<#out+4,r5,#3>		; do proj.
	clr	r5
	bisb	ppn,r5
	calls	l$cvtnum,<#out+8.,r5,#-3>

4$:	cmp	kb,#128.
	blt	5$
	movb	#'D,out+13.
	mov	#"et,out+14.
	br	7$

5$:	calls	l$cvtnum,<#out+15.,kb,#-2>	; do kb number
	tst	contrl				; controlling job ?
	beq	7$
	movb	#'C,out+16.
	calls	l$cvtnum,<#out+17.,contrl,#-2>	; do controller

7$:	mov	#out+23.,r0
	mov	name,r1
	calls	radasc,<r0,r1>
	mov	#out+26.,r0
	mov	name+2,r1
	calls	radasc,<r0,r1>

	movb	prirun,r5
	calls	l$cvtnum,<#out+33.,r5,#4>	; prio.
	clr	r5
	bisb	prirun+1,r5
	calls	l$cvtnum,<#out+38.,r5,#-3>	; runb.

	mov	cpu,r1
	clr	r0
	div	#600.,r0
	tst	r0
	beq	10$
	movb	#':,out+48.
	calls	l$cvtnum,<#out+45.,r0,#3>

10$:	clr	r0
	div	#10.,r0
	calls	l$cvtnum,<#out+49.,r0,#2>
	calls	l$cvtnum,<#out+52.,r1,#1>

	mov	jbstat,r0			; done runtime, now job state
	bit	jbwait,r0
	bne	11$				; RN
	bit	jbwait,#4000
	bne	13$				; TT
	bit	jbwait,#1
	bne	15$				; DP
	bit	jbwait,#10000
	bne	16$				; FP
	bit	jbwait,#20000
	bne	17$				; SL
	bit	kbtmo,#100000
	bne	12$				; ^C
	bit	jbwait,#2
	bne	14$				; KB
	tst	jbwait
	beq	18$				; HB
	mov	#"??,out+54.			; god knows
	br	19$
;
;	This modification done 10-Aug-87.  Based on a combination of
;	information from SYSTAT,TELL and Steve's SYSTAT BCPL program.
;	Note that TELL (at the moment) interprets a SL state as a ^C
;	state.  You must have these checks in this order (or at least
;	SL,^C,KB in that order).  Surprisingly, this mod. doesn't
;	slow ZAPPER down noticeably.  This is due to the lack of
;	complicated code - simply a few tests and a move.  Since
;	the output is buffered, the extra output due to this feature
;	doesn't make any difference.
;

11$:	mov	#"RN,out+54.
	br	19$
12$:	mov	#"^C,out+54.
	br	19$
13$:	mov	#"TT,out+54.
	br	19$
14$:	mov	#"KB,out+54.
	br	19$
15$:	mov	#"DP,out+54.
	br	19$
16$:	mov	#"FP,out+54.
	br	19$
17$:	mov	#"SL,out+54.
	br	19$
18$:	mov	#"HB,out+54.

19$:	.print	#out,#56.
	.newline
	return


didprt:	.word	0
namasc:	.blkw	6
dtahed:	.ascii	<13.><10.>
	.ascii	"Job   PPN     KB       Program    Pri/Rnb"
	.ascii	"    Run-Time State"
	.ascii	<13.><10.>
	.ascii	<0.>
	.even
out:	.blkb	57.
	.even
linfrm:	.ascii	@     ??,??   KB                      /   @
	.ascii	@          .  @
	.blkb	8.
	.even

status:	return

send:	tst	wntppn
	beq	1$				; don't send to own job in
	cmp	job,ownjob
	beq	10$
1$:	calls	$zapxrb
	mov	#6.,xrb
	mov	#12.,xrb+2			; length of header
	mov	#sndhed,xrb+4
	movb	#2,xrb+7
	mov	kb,xrb+10
	.spec
	.len	#arg2
	mov	r0,xrb+2
	mov	#arg2,xrb+4
	.spec
	mov	#2,xrb+2
	mov	#crlf,xrb+4
	.spec
10$:	return

sndhed:	.ascii	<13.><10.>/Zapper >> /
crlf:	.ascii	<13.><10.>

prio:	clr	er$sav
	.val	#arg2,#20.			; get priority to put at
	iferr	2$				; silly priority
	cmp	r0,#120.
	bgt	2$
	cmp	r0,#-128.
	blt	2$
	calls	$zapfqb
	movb	#uu.pri,firqb+fqfun
	movb	job,firqb+4
	movb	#255.,firqb+5
	movb	r0,firqb+6
	.uuo
	return

2$:	.newline
	.print	#prierr				; silly priority
	.newline
	add	#2,sp				; reset sp
	jmp	doit

prierr:	.asciz	/?Illegal priority or runburst./
	.even

runb:	clr	er$sav
	.val	#arg2,#20.			; get runburst value
	iferr	2$
	tst	r0
	ble	2$
	cmp	r0,#127.
	bgt	2$
	calls	$zapfqb
	movb	#uu.pri,firqb+fqfun
	movb	job,firqb+4
	movb	#255.,firqb+7
	movb	r0,firqb+10
	.uuo
	return

2$:	.newline
	.print	#prierr
	.newline
	add	#2,sp
	jmp	doit

kill:	tst	wntppn				; if we're killing an account
	beq	1$				; then we don't want to kill
	cmp	job,ownjob			; our own job halfway through
	bne	1$
	return

1$:	calls	$zapfqb
	movb	#uu.chu,firqb+fqfun
	movb	job,firqb+4
	clrb	firqb+34
	movb	#377,firqb+35
	.uuo
	return

det:	calls	$zapfqb
	mov	job,r0				; we may want to close chans
	cmpb	arg2,#'C
	bne	1$
	add	#128.,r0			; close all kb chans
1$:	movb	r0,firqb+4
	movb	#uu.det,firqb+fqfun
	.uuo
	return

slow:	call	$zapfqb
	movb	#uu.pri,firqb+fqfun
	movb	job,firqb+4
	movb	#255.,firqb+5
	movb	#-120.,firqb+6
	movb	#255.,firqb+7
	movb	#3,firqb+8.
	.uuo					; slow puts at -120/3
	return

susp:	tst	wntppn				; don't want to suspend
	beq	1$
	cmp	job,ownjob			; own job if doing a lot
	beq	10$

1$:	calls	$zapfqb
	movb	#uu.pri,firqb+fqfun
	movb	job,firqb+4
	movb	#255.,firqb+5
	movb	#-128.,firqb+6			; suspend is -128
	.uuo

10$:	return

force:	tst	wntppn				; don't want to force to
	beq	1$
	cmp	job,ownjob			; own job if doing lots
	beq	10$

1$:	.len	#arg2
	clr	r1

2$:	cmpb	arg2(r1),#'^			; we want to convert
	bne	3$				; ^C to actual code
	inc	r1
	cmpb	arg2(r1),#'A
	blt	3$
	cmpb	arg2(r1),#'Z
	bgt	3$
	movb	arg2(r1),r2
	sub	#64.,r2				; do the conversion
	movb	r2,arg2(r1)
	dec	r1
	movb	#128.,arg2(r1)			; not null so len works

3$:	inc	r1
	cmp	r1,r0
	blt	2$				; do for whole string

	calls	$zapxrb
	mov	#5,xrb
	mov	r0,xrb+2
	mov	#arg2,xrb+4
	movb	#2,xrb+7
	mov	kb,xrb+10
	.spec					; do the force
	dec	r0				; want last character
	cmpb	arg2(r0),#32.			; if it didn't end on a
	blt	10$				; control character then we
	mov	#1,xrb+2			; want to force a cr
	mov	#fcr,xrb+4
	.spec

10$:	return

fcr:	.ascii	<13.>
	.even

	.end	start

