	.title	systat
	.list	ttm
	.nlist	bin
	.nlist
	$rsx
	$rwdef
	.globl	bf$pnt
;
;	This is a MACRO version of the utility SYSTAT.BAS. I'm basically fed
;	up with the slow speed of the BASIC version.  This one should,
;	eventually, do all that the old version does, but substantially
;	faster.
;
;	While writing this, I noticed that SYSTAT.BAS is twice as fast if
;	you RUN it than if you use CCL entry.  This is about the worst case
;	of overhead I've seen!  I think it has something to do with the
;	switch parsing that goes on at line 30000.
;
;		E.D.W. Hibbert    August 1987
;
;
;	Compilation:	MACR SYSTAT=PA:DEFS,A:[1,95]SYSTAT (or wherever)
;		(use MACR rather than MAC as it is about twice as fast.)
;			TKB $SYSTAT.TSK<232>=SYSTAT,PA:IOLIB/LB
;
;
;	Developement :
;
;
;	12/8/87	Initial coding - command routine & switch processing
;	13/8/87 Basics - getdta & prtdta
;	14/8/87 prtdta completed - now gets state correctly
;		Basic switches - /A/N/P/U
;		Switches work in combination.  /AU would behave differently
;		to SYSTAT.BAS, but who in their right mind...
;		/G switch coding
;		/G switch works.  Filesizes >32767 blocks will be displayed
;		incorrectly, but I don't think that's really a problem.
;		Modes (eg Rd,RR) on /G work.  /G now complete.
;		Swap status put into prtdta
;	17/8/87	Systat by job number, keyboard number
;		Job number, keyboard number work.  Basic switches (AGNPSU,n,Kn)
;		now working.
;		/B switch done & working.
;		Systat by account number coded & working - inc. wildcards
;		/R switch coded
;	18/8/87	/R switch working
;		/F switch coded and working
;		/D switch coding started
;	19/8/87	/D switch coding continued.  Double precision routines
;		for disk size coded & working.  I am now in a position to
;		modify /G so that filesizes>32767 are displayed correctly,
;		but I'll leave that.  I really don't think it's important.
;		/D complete bar % free
;	20/8/87	% free for /D done.  Won't work for disk size >320M, but
;		that's not a real restriction.
;		Slight bug in /B fixed - might not print 'Why' correctly,
;		depending on whether the output buffer was full!
;		/L coded & working.
;		/M coded & working
;	21/8/87	CCL entry coded & tested
;		/I switch coded
;	24/8/87	/I switch works
;		Edited to flush buffer after /I, and to clear it
;
;		------------------------------------------------
;
;	01/9/87	/PROG: switch works - put in before normal switch check
;		so that /PROG is not interpreted as /P,/R,error.
;		Only /C,/O,/W switches remain.
;	02/9/87	/G modified so that sizes >32767 work OK.
;	4/11/87	Routine DODSK modifed - current position was in fact
;		getting the wrong high byte, which lead to corrupt
;		positions - now fixed.
;

	.macro	output	stradr,strlen
	save	<r5,r0>
	.if	b,strlen
	 .ift
	  .len	stradr
	 .iff
	  mov	strlen,r0
	.endc
	calls	l$plin,<#buf,#1,stradr,r0>
	unsave	<r0,r5>
	.endm	output

start:	clr	ccl			; assume no ccl entry
	.stat
	tst	xrb+10			; logged out entry?
	bne	90$
	inc	ccl
	clr	r0
	br	31$			; yes, do it
90$:	tst	firqb+fqent
	beq	30$			; ccl entry?
	tstb	corcom			; anything else typed?
	beq	30$
	clr	r0

31$:	inc	r0
	cmpb	corcom(r0),#32.
	beq	32$
	cmpb	corcom(r0),#'/
	beq	32$			; want to scan past name
	cmpb	r0,corcom		; end ?
	ble	31$
	clrb	cmd			; yes, goto normal entry
	inc	ccl
	br	30$

32$:	movb	corcom,r2
	mov	r2,r1
	sub	r0,r1

33$:	movb	corcom(r2),cmd(r1)	; copy text
	dec	r1
	dec	r2
	cmp	r2,r0
	bge	33$
	inc	ccl			; set flag

30$:	.lmargin
	movb	#uu.tb1,firqb+fqfun	; want monitor tables 1
	.uuo
	mov	firqb+6,devcnt
	mov	firqb+10,devptr
	mov	firqb+12,memlst
	mov	firqb+22,untclu
	mov	firqb+24,untcnt
	mov	firqb+26,satctl
	mov	firqb+32,satctm
	mov	firqb+36,untown
	movb	#uu.tb2,firqb+fqfun	; want to get monitor tables 2
	.uuo
	mov	firqb+4,frees
	mov	firqb+6,devnam
	mov	firqb+10,csrtbl
	mov	firqb+12,devokb
	mov	firqb+14,ttyhct
	mov	firqb+16,jobcnt
	mov	firqb+20,rtslst
	mov	firqb+22,erlctl
	mov	firqb+24,sndlst
	mov	firqb+26,lognam
	mov	firqb+30,devsyn
	mov	firqb+32,memsiz
	mov	firqb+34,ccllst
	mov	firqb+36,fcblst
	movb	#-29.,firqb+fqfun	; want monitor tables 3
	.uuo
	mov	firqb+4,ddctbl
	mov	firqb+6,ucttbl
	call	gtdknm			; set up list of disk names

	tst	ccl
	bne	34$
	.print	#prghed
	.errprt	#0
	.newline
	.print	#prompt
	.input	#cmd			; get the command
	.newline

34$:	.len	#cmd
	mov	r0,r4			; get length
	clr	r3			; in case of no O/P file
	calls	cvt$$,<#cmd,r4,#255.>	; tidy it up
	mov	r0,r4			; get new length
	beq	3$			; they type nothing
	clrb	cmd(r4)			; put null terminator
	cmpb	cmd,#'/			; is first character a slash?
	beq	3$			; yes, default output file
	.stat				; if logged out no output file allowed
	tst	xrb+10			; logged out?
	bne	1$			; no, get output file
	.exit				; yes, abort instead

3$:	calls	$zapfqb			; use KB: as default O/P file
	movb	#opnfq,firqb+fqfun	; want to open a file
	movb	#2,firqb+fqfil		; on channel 1
	mov	#"KB,firqb+fqdev	; device is keyboard
	calfip				; do the open
	tstb	firqb			; unlikely to have got an error
	bne	4$			; but check anyway
	cmpb	cmd,#'/			; no error. any switches?
	beq	5$			; yes, carry on
	movc	#defswi,#cmd,#8.	; no, copy default switches
	mov	#8.,r4			; store length for later
	br	5$			; and carry on

1$:	calls	instr,<#cmd,r4,#slash,#1> ; we want to find the output filename
	mov	r0,r3			; start of switches
	bne	2$			; there were some switches
	mov	r4,r0
	add	#cmd,r0			; no, want to give default
	movc	#defswi,r0,#8.		; copy across the default switches
	save	r4			; temp.
	.len	#cmd			; get length
	mov	r0,r4			; new length of string+switches
	unsave	r3			; now r3 holds position of slash
	inc	r3			; it's going to be decremented

2$:	dec	r3			; correct for start at 0
	calls	$zapxrb			; now do a filename string scan
	calls	$zapfqb
	mov	r3,xrb			; length of filename
	mov	r3,xrb+xrbc		; again
	mov	#cmd,xrb+xrloc		; start address
	.fss				; do the filename string scan
	tstb	firqb			; error?
	bne	4$			; yes,tell them
	mov	#jfsys,xrb		; want to drop privs
	.clear
	movb	#crefq,firqb+fqfun	; want to open output file
	movb	#2,firqb+fqfil		; on channel 1
	calfip				; open
	tstb	firqb			; error ?
	beq	5$			; no,carry on

4$:	movb	firqb,r1		; save error number
	.newline
	.print	#filerr			; error on output file
	.errprt	r1			; print error message
	.newline
	.exit				; finish

5$:	mov	#jfsys,xrb		; want privs
	.set				; regain them
	clr	flag			; zero switch flag
	mov	r3,r1			; want to process the first switch

6$:	cmp	r1,r4			; end of switches?
	blt	35$
	jmp	10$

35$:	cmpb	cmd(r1),#'/		; slash
	bne	7$			; no

	inc	r1			; skip it
7$:	bit	#32768.,flag		; /PROG: ?
	bne	50$
	cmpb	cmd(r1),#'P
	bne	50$
	cmpb	cmd+1(r1),#'R
	bne	50$
	cmpb	cmd+2(r1),#'O
	bne	50$
	cmpb	cmd+3(r1),#'G
	bne	50$
	cmpb	cmd+4(r1),#':
	bne	50$			; sophisticated eh?
	save
	add	#cmd+5,r1
	mov	#prog,r0

51$:	cmpb	(r1),#'/
	beq	52$
	cmpb	(r1),#32.
	blt	52$
	movb	(r1)+,(r0)+
	br	51$

52$:	calls	ascrad,<#prog>
	mov	r0,wntnm1
	calls	ascrad,<#prog+3>
	mov	r0,wntnm2
	add	#32768.,flag
	mov	r1,out
	unsave
	mov	out,r1
	sub	#cmd,r1
	jmp	6$


50$:	clr	r3			; start looking for switches.
					; NB assumed R3 no longer needed

8$:	cmpb	swi(r3),cmd(r1)
	bne	36$
	jmp	9$

36$:	add	#2,r3			; next switch
	tst	swi(r3)			; end of switches?
	bne	8$			; no, check it
	cmpb	cmd(r1),#'K		; are they asking for a keyboard?
	bne	22$			; no
	bit	#64.,flag		; have they already specified one
	bne	25$			; yes, don't be silly
	inc	r1
	call	getarg			; get the number
	bcs	25$			; failed
	mov	r0,wntkb		; save the keyboard they want
	add	#64.,flag		; set the flag
	jmp	6$			; and do next switch

22$:	bit	#128.,flag		; already given a job number?
	bne	40$			; yes, can't give another
	call	getarg			; try for job number
	bcs	40$			; failed
	mov	r0,wntjob		; save the job they want
	add	#128.,flag		; and set flag
	jmp	6$			; and do next switch

25$:	.newline
	.print	#swierr			; unrecognised switch
	.newline
	.exit

40$:	cmpb	cmd(r1),#'I		; check for /I
	bne	23$
	cmpb	cmd+1(r1),#':		; should be /I:
	bne	23$
	add	#2,r1			; skip past I:
	cmpb	cmd(r1),#'/		; check for no arg. specified
	beq	41$
	cmpb	cmd(r1),#32.
	ble	41$
	call	getarg			; get numeric value
	bcc	37$			; got ok
	sub	#2,r1			; maybe something else so restore
	br	23$

37$:	mov	r0,del
	jmp	6$			; more switches

41$:	mov	#30.,del		; default delay 30 secs
	jmp	6$

23$:	bit	#512.,flag		; must be account, if anything
	beq	70$			; already done one?
	jmp	25$
70$:	save
	mov	#1,r0

24$:	movb	cmd(r1),filscn(r0)	; want to do fss
	inc	r1
	inc	r0
	cmpb	cmd(r1),#'/		; end?
	beq	27$			; yes
	cmpb	cmd(r1),#32.		; end?
	blt	27$			; yes
	br	24$			; repeat until it's done

27$:	calls	$zapxrb
	.len	#filscn
	mov	r0,xrb
	mov	r0,xrb+2
	mov	#filscn,xrb+4
	.fss
	mov	firqb+fqppn,wntppn	; get the account they want
	bne	56$			; valid
	jmp	25$
56$:	add	#512.,flag		; set the flag
	jmp	6$			; look for more switches

9$:	add	flg(r3),flag		; set the bit
	inc	r1			; next switch
	jmp	6$			; check it

10$:	.newline
	bit	#33535.,flag		; do we want to print the header
	bne	14$			; yes
	jmp	26$			; no, skip header

14$:	movb	#uu.err,firqb+fqfun	; want system header
	clrb	firqb+4			; which is error 0
	.uuo
	output	#firqb+4,#28.		; print it
	output	#stms1			; status at
	.date				; get date & time
	calls	$zapfqb
	mov	xrb,firqb+4		; set up to convert date
	mov	xrb+2,firqb+22		; set up to convert time
	movb	#uu.cnv,firqb+fqfun	; date/time conversion
	.uuo				; do it
	clrb	firqb+22
	movb	#32.,firqb+23		; put a space in
	movb	#',,firqb+24		; and a comma
	movb	#32.,firqb+25		; and another space
	output	#firqb+10,#24.		; and print it out
	output	#crlf,#2
	output	#crlf,#2
	output	#sthed			; print the job table header

	mov	#1,job			; start SYSTAT at job 1

11$:	call	getdta			; get job info
	cmpb	firqb,#10.		; any job with that number?
	bne	46$
	jmp	20$
46$:	tstb	firqb			; any other error
	beq	12$			; no, carry on
26$:	call	slashb			; do /B if required
	call	slashd			; do /D if required
	call	slashf			; do /F if required
	call	slashr			; do /R if required
	call	slashl			; do /L if required
	call	slashm			; do /M if required
	output	#crlf			; yes, end of systat
	calls	l$flush,<#buf,#1>	; finish output
	tst	del			; /I:?
	beq	45$			; no, exit
	clr	bf$pnt+2		; we've done this output now
	$sleep	del
	jmp	10$			; sleep & repeat

45$:	calls	l$close,<#1>		; close channel
	.exit				; and we've finished

12$:	bit	#8.,flag		; want /P?
	beq	13$			; no, we don't
	cmpb	ppn+1,#1		; is this a [1,*] job?
	bne	20$			; no, so don't want this job

13$:	bit	#1,flag			; want /A?
	beq	16$			; no
	cmp	kb,#128.		; attached?
	bgt	20$			; no, so don't want this job

16$:	bit	#32.,flag		; want /U
	beq	15$			; no
	cmp	kb,#128.		; attached
	blt	20$			; yes, so don't want this job

15$:	bit	#4,flag			; want /N
	beq	17$			; no
	cmpb	ppn+1,#1		; is this a [1,*] job?
	beq	20$			; yes, so don't want this job

17$:	bit	#64.,flag		; do we want /K?
	beq	18$			; no
	cmp	kb,wntkb		; does the keyboard match?
	bne	20$			; no, so don't want this job

18$:	bit	#128.,flag		; do we want a job number?
	beq	21$			; no
	cmp	job,wntjob		; does number match
	bne	20$			; no, so don't want this job

21$:	bit	#512.,flag		; want an account?
	beq	55$			; no
	call	matppn			; check the account
	bcs	20$			; failed

55$:	bit	#32768.,flag		; want a prog. name
	beq	19$
	cmp	wntnm1,nam1
	bne	20$
	cmp	wntnm2,nam2
	bne	20$

19$:	call	prtdta			; print it as it passed all checks
	bit	#2,flag			; want /G?
	beq	20$			; no
	call	slashg			; do open file information

20$:	inc	job			; do next
	jmp	11$			; go to it

getarg:	mov	r1,-(sp)		; save position in case we fail
	clr	r0

1$:	cmpb	cmd(r1),#'/		; end of switch?
	beq	15$			; yes, possible success
	cmpb	cmd(r1),#32.		; or end of string ( = end of switch )
	blt	15$			; yes, possible success
	cmpb	cmd(r1),#'0
	blt	10$			; fail
	cmpb	cmd(r1),#'9
	bgt	10$			; fail
	movb	cmd(r1),r5		; get the character
	sub	#'0,r5			; convert from ASCII
	asl	r0
	mov	r0,-(sp)
	asl	r0
	asl	r0
	add	(sp)+,r0		; multiply by 10
	add	r5,r0			; and add in new one
	inc	r1			; try next character
	br	1$

10$:	mov	(sp)+,r1		; failed, so restore position
	sec
	return

15$:	cmp	r1,(sp)			; was it a blank switch?
	beq	10$			; yes, failed
	tst	(sp)+			; don't want the old r3 value
	clc
	return

matppn:	cmp	ppn,wntppn		; obvious match?
	beq	5$			; yes
	cmpb	ppn,wntppn		; may have *
	beq	1$			; that matches
	cmpb	wntppn,#255.		; check for * as that fits too
	beq	1$
	jmp	6$			; no, failed match

1$:	cmpb	ppn+1,wntppn+1
	beq	5$			; yes, matches
	cmpb	wntppn+1,#255.		; * here?
	beq	5$			; yes, matches
	jmp	6$			; failed, I'm afraid

5$:	clc
	return

6$:	sec
	return

getdta:	calls	$zapfqb
	movb	#uu.sys,firqb+fqfun	; might as well do the sys call
	movb	job,firqb+4		; considering how fast ZAPPER is.
	.uuo				; get the first lot of data
	movb	firqb+5,kb		; get the keyboard
	movb	firqb+7,swap		; swap slot
	asrb	firqb+6			; want controlling job
	movb	firqb+6,contrl		; get controlling job, if any
	mov	firqb+10,cpu		; low word of cpu time
	movb	firqb+21,cpu1		; high word of cpu time
	mov	firqb+22,nam1		; job name part 1
	mov	firqb+24,nam2		; job name part 2
	mov	firqb+26,ppn		; account number
	mov	firqb+34,rts1		; run time system part one
	mov	firqb+36,rts2		; run time system part two
	calls	$zapfqb			; now do the second subfunction
	movb	#uu.sys,firqb+fqfun
	movb	job,firqb+4
	movb	#1,firqb+5		; second subfunction
	.uuo				; get the other lot of data
	mov	firqb+12,jbstat		; jbstat word
	mov	firqb+14,jbwait		; jbwait - used for state
	movb	firqb+16,jbsiz		; current job size
	mov	firqb+22,prirun		; priority/runburst
	movb	firqb+24,maxsiz		; memory maximum
	mov	firqb+26,kbtmo		; used for state
	mov	firqb+32,jdb		; pointer to jdb
	mov	firqb+34,jdb2		; pointer to jdb2
	return				; got all we need now

prtdta:	movc	#linfrm,#out,#80.	; get blank output line
	calls	l$cvtnum,<#out,job,#2>	; print job
	tst	ppn			; logged out?
	beq	1$			; yes, so covered in default line
	clr	r0
	bisb	ppn+1,r0		; get proj
	calls	l$cvtnum,<#out+5,r0,#3>	; do proj
	clr	r0
	bisb	ppn,r0			; get prog
	calls	l$cvtnum,<#out+9.,r0,#-3> ; do prog, centered nicely

1$:	cmp	kb,#128.		; detached?
	bgt	3$			; yes, so done in default line
	mov	#"KB,out+14.		; assume kb unless proved otherwise
	tst	contrl			; is it a pk?
	beq	2$
	mov	#"PK,out+14.

2$:	calls	l$cvtnum,<#out+16.,kb,#-2> ; do keyboard number
	tst	contrl
	beq	3$			; if not pk then we're finished here
	mov	#out+17.,r0
	cmpb	(r0),#32.		; check for formatting
	beq	4$
	inc	r0

4$:	movb	#'J,(r0)+		; put the 'J'
	calls	l$cvtnum,<r0,contrl,#-2> ; do controlling job number

3$:	calls	radasc,<#out+22.,nam1>	; do first three letters of name
	calls	radasc,<#out+25.,nam2>	; and next three
	calls	l$cvtnum,<#out+30.,jbsiz,#2> ; do job size
	calls	l$cvtnum,<#out+33.,maxsiz,#2> ; do memory maximum

5$:	movb	#'R,out+39.
	movb	#'N,out+40.
	bit	jbwait,jbstat
	bne	20$			; RN?
	movb	#'S,out+39.
	movb	#'L,out+40.
	bit	#8192.,jbwait
	bne	6$			; SL?
	movb	#'F,out+39.
	movb	#'P,out+40.
	bit	#4096.,jbwait
	bne	20$			; FP?
	movb	#'T,out+39.
	movb	#'T,out+40.
	bit	#2048.,jbwait
	bne	20$			; TT?
	movb	#'H,out+39.
	movb	#'B,out+40.
	tst	jbwait
	beq	20$			; HB?
	movb	#'^,out+39.
	movb	#'C,out+40.
	bit	kbtmo,#100000
	bne	20$			; ^C?
	movb	#'K,out+39.
	movb	#'B,out+40.
	bit	#2,jbwait
	bne	20$			; KB is easy to check.  Would be
					; found next, but might as well check
					; now.
	call	getdev			; it's waiting for a device - find it

8$:	cmpb	out+39.,#32.		; legal device?
	bne	20$			; yes, ok
	movb	#'?,out+39.		; god knows
	movb	#'?,out+40.
	br	20$

6$:	mov	jdb,xrb
	add	#4,xrb
	.peek
	cmpb	xrb,#5			; error = 5 ?
	bne	20$
	movb	#'R,out+40.
	br	20$			; yes, sleep receiver state

20$:	bit	#63.,swap
	beq	22$
	mov	#65.,r0
	mov	swap,r1
	asr	r1
	asr	r1
	asr	r1
	asr	r1
	asr	r1
	asr	r1
	add	r1,r0
	movb	r0,out+42.		; swap file
	mov	swap,r0
	asl	r1
	asl	r1
	asl	r1
	asl	r1
	asl	r1
	asl	r1
	sub	r1,r0			; get swap location
	calls	l$cvtnum,<#out+43.,r0,#2> ; do location
	cmpb	out+43.,#32.		; format
	bne	22$
	movb	#'0,out+43.

22$:	mov	cpu,r3			; now do the runtime
	mov	cpu1,r2			; high
	div	#600.,r2
	tst	r2
	beq	21$
	calls	l$cvtnum,<#out+47.,r2,#4> ; do the minutes
	movb	#':,out+51.		; put the colon

21$:	clr	r2
	div	#10.,r2
	calls	l$cvtnum,<#out+52.,r2,#2> ; do the seconds
	cmpb	out+51.,#':		; now we want
	bne	23$
	cmpb	out+52.,#32.		; do some formatting
	bne	23$
	movb	#'0,out+52.

23$:	calls	l$cvtnum,<#out+55.,r3,#1> ; done the runtime now

25$:	movb	prirun,r0		; get priority
	calls	l$cvtnum,<#out+57.,r0,#4> ; do prio
	clr	r0
	bisb	prirun+1,r0		; get runburst
	calls	l$cvtnum,<#out+62.,r0,#-3> ; do runburst
	calls	radasc,<#out+66.,rts1>	; first three letters of rts
	calls	radasc,<#out+69.,rts2>	; second three letters of rts

	output	#out,#80.
	return

getdev:	mov	jdb,xrb			; want to find the device now
	add	#6,xrb
	.peek
	add	#6,xrb
	.peek
	movb	xrb,r0
	mov	jdb,xrb
	.peek
	add	r0,xrb
	.peek
	mov	xrb,r1			; save for later
	.peek
	movb	xrb,r0
	bne	7$			; non disk device?
	tst	fcblst
	beq	1$
	mov	r1,xrb
	add	#8.,xrb
	.peek
	sub	#4,xrb
	.peek
	movb	xrb,r0
	br	2$
1$:	mov	r1,xrb
	add	#2,xrb
	.peek
	movb	xrb+1,r0
2$:	mul	#10.,r0
	mov	r1,xrb
	add	#4,xrb
	add	lognam,xrb
	.peek
	movb	xrb,out+39.		; now we've found the device type
	movb	xrb+1,out+40.		; get both characters
	br	8$			; and go and check it

7$:	mov	devnam,xrb
	add	devokb,xrb
	add	r0,xrb
	sub	#2,xrb
	.peek
	movb	xrb,out+39.		; get device name
	movb	xrb+1,out+40.		; second character

8$:	return				; now we know the actual device

slashg:	mov	jdb,xrb
	.peek
	mov	xrb,r4			; r4 ---> IOB
	clr	r1			; r1 = chan*2 for loop

1$:	tst	r1			; don't want channel 0 if detached
	bne	2$
	cmp	kb,#128.
	blt	2$			; not detached, do channel 0
	add	#2,r1			; skip to channel 1

2$:	movc	#slgfrm,#out,#80.	; set up default line
	mov	r4,xrb
	add	r1,xrb
	.peek
	mov	xrb,r3			; r3 ---> WCB
	beq	21$			; nothing open?
	.peek
	mov	xrb,r5			; r5 = ST
	movb	xrb,r2			; r2 = DRV.IDX
	beq	5$			; go elsewhere if a disk file
	mov	devnam,xrb
	add	devokb,xrb
	add	r2,xrb
	sub	#2,xrb
	.peek				; get device type
	mov	xrb,out+16.		; and put it in output line
	mov	r3,xrb
	add	#2,xrb
	.peek				; get unit number of the device
	movb	#':,out+18.
	cmp	out+16.,#"NL
	beq	20$			; no number for null device
	cmp	out+16.,#"KB
	bne	3$			; for keyboard, may be own
	cmpb	xrb+1,kb		; is it own?
	bne	3$			; no
	br	20$			; yes, skip number

3$:	movb	xrb+1,r0		; get unit number
	calls	l$cvtnum,<#out+18.,r0,#-2> ; put the keyboard
	mov	#out+19.,r0		; want to format
	cmpb	(r0),#32.		; if a space then
	beq	4$			; put colon here else
	inc	r0			; move onto next

4$:	movb	#':,(r0)		; put the colon
	br	20$			; do next channel

5$:	call	dodsk			; do the disk file

20$:	mov	r1,r0			; channel*2
	asr	r0			; get channel
	calls	l$cvtnum,<#out+12.,r0,#-2> ; put the channel
	output	#out,#79.		; do the output
	output	#crlf,#2

21$:	add	#2,r1			; next channel
	cmp	r1,#30.			; end (ie channel 15?)
	bgt	22$			; yes, end
	jmp	2$			; no, do next channel

22$:	output	#crlf,#2		; put an extra blank line, prettier
	return

dodsk:	mov	r3,xrb
	add	#6,xrb
	.peek
	mov	xrb,cmd
	mov	r3,xrb
	add	#4,xrb
	.peek
	clr	r0
	bisb	xrb+1,r0
	calls	l$cvtli,<#out+43.,r0,cmd> ; position
	mov	#out+44.,r2

110$:	cmpb	(r2),#'0
	bne	111$
	movb	#32.,(r2)+
	cmp	r2,#out+50.
	blt	110$

111$:	mov	r3,xrb
	add	#8.,xrb
	.peek
	sub	#28.,xrb
	mov	xrb,r2			; r2 ---> FCB
	add	#24.,xrb
	.peek
	movb	xrb,r0
	asl	r0
	asl	r0			; quick multiply by four
	mov	dsknam(r0),out+16.	; get disk name
	mov	dsknam+2(r0),out+18.	; and number
	movb	#':,out+20.		; stick a colon in
	jmp	101$
100$:	jmp	1$
101$:	movb	#'[,out+21.
	mov	r2,xrb
	add	#4,xrb
	.peek				; get account
	clr	r0
	bisb	xrb+1,r0		; get proj
	calls	l$cvtnum,<#out+22.,r0,#3> ; output proj
	clr	r0
	bisb	xrb,r0			; get prog
	calls	l$cvtnum,<#out+26.,r0,#-3> ; output prog
	movb	#',,out+25.		; stick a comma in
	movb	#'],out+29.		; and close brackets
	bit	r5,#256.		; NFS
	bne	100$
	bit	#16384.,r5
	bne	100$
	mov	r2,xrb
	add	#6,xrb
	.peek
	calls	radasc,<#out+30.,xrb>	; first three characters of filename
	mov	r2,xrb
	add	#8.,xrb
	.peek
	calls	radasc,<#out+33.,xrb>	; second three characters
	movb	#'.,out+36.		; stick a dot in
	mov	r2,xrb
	add	#10.,xrb
	.peek
	calls	radasc,<#out+37.,xrb>	; extension
	movb	#'<,out+40.
	movb	#'>,out+44.
	mov	r2,xrb
	add	#12.,xrb
	.peek
	clr	r0
	bisb	xrb+1,r0
	calls	l$cvtnum,<#out+41.,r0,#-3> ; protection code
	cmpb	out+43.,#32.		; format
	bne	1$
	movb	#'>,out+43.
	movb	#32.,out+44.

1$:	movb	#'o,out+52.
	movb	#'f,out+53.
	mov	r2,xrb
	add	#26.,xrb
	.peek
	mov	xrb,cmd
	mov	r2,xrb
	add	#24.,xrb
	.peek
	movb	xrb+1,r0
	calls	l$cvtli,<#out+54.,r0,cmd>
	mov	#out+55.,r0

120$:	cmpb	(r0),#'0
	bne	121$
	movb	#32.,(r0)+
	cmp	r0,#out+61.
	blt	120$

121$:	save	r1
	mov	#out+55.,r1
122$:	movb	(r0),(r1)+
	movb	#32.,(r0)+
	cmpb	(r0),#32.
	bne	122$
	unsave	r1
	mov	r3,xrb
	add	#12.,xrb
	.peek
	mov	#out+62.,r0		; now for modes & things
	bit	#256.,r5
	beq	2$
	movb	#'N,(r0)+
	movb	#'F,(r0)+
	movb	#'S,(r0)+
	movb	#',,(r0)+

2$:	bit	#512.,r5
	bne	3$
	movb	#'R,(r0)+
	movb	#'d,(r0)+
	movb	#',,(r0)+

3$:	bit	#1024.,r5
	bne	4$
	movb	#'W,(r0)+
	movb	#'r,(r0)+
	movb	#',,(r0)+

4$:	bit	#16384.,r5
	beq	5$
	movb	#'U,(r0)+
	movb	#'F,(r0)+
	movb	#'D,(r0)+
	movb	#',,(r0)+

5$:	bit	#16.,xrb
	beq	6$
	movb	#'S,(r0)+
	movb	#'q,(r0)+
	movb	#',,(r0)+

6$:	bit	#8.,xrb
	beq	7$
	movb	#'C,(r0)+
	movb	#'a,(r0)+
	movb	#',,(r0)+

7$:	bit	#1,xrb
	beq	8$
	movb	#'R,(r0)+
	movb	#'R,(r0)+
	movb	#',,(r0)+

8$:	bit	#2048.,r5
	bne	9$
	bit	xrb,#2
	beq	15$
	movb	#'T,(r0)+
	movb	#'e,(r0)+
	movb	#'n,(r0)+
	movb	#'t,(r0)+
	movb	#',,(r0)+
	br	15$

9$:	movb	#'U,(r0)+
	movb	#'p,(r0)+
	movb	#',,(r0)+
	bit	#2,xrb
	beq	15$
	sub	#3,r0
	movb	#'S,(r0)+
	movb	#'p,(r0)+
	movb	#'U,(r0)+
	movb	#'p,(r0)+
	movb	#',,(r0)+

15$:	cmp	r0,#out+61.
	beq	16$
	movb	#32.,-(r0)			; trim off last comma, if any

16$:	return

slashb:	bit	#256.,flag		; do they want it?
	bne	1$			; yes
	return				; no, return

1$:	output	#crlf,#2
	clr	r3
	output	#slbms1			; 'Busy devices:'
	mov	devcnt,r1
	add	devokb,r1
	mov	devptr,xrb
	add	devokb,xrb
	.peek
	mov	xrb,r2
	mov	devsyn,-(sp)		; we'll use the stack as a data store
	sub	#2,(sp)			; (sp) = limit of outer (r4) loop
	mov	devnam,r4
	add	devokb,r4		; lower limit for outer loop

2$:	mov	r1,xrb
	.peek
	mov	xrb,-(sp)
	mov	r4,xrb
	.peek
	mov	xrb,-(sp)		; now (sp) = current device type
					;    2(sp) = limit for r5 loop
					;    4(sp) = limit for r4 loop
	clr	r5

3$:	mov	r2,xrb
	.peek
	mov	xrb,r0
	add	#2,xrb
	.peek
	movb	xrb,temp
	beq	15$			; next for inner loop
	bit	#1,temp
	beq	4$
	cmp	temp,#3
	beq	4$
	cmp	temp,#5
	beq	4$
	br	15$

15$:	inc	r5
	add	#2,r2
	cmp	r5,2(sp)
	ble	3$			; inner loop
	add	#2,r1
	add	#4,sp			; restore for device type
	add	#2,r4
	cmp	r4,(sp)
	ble	2$			; next device
	tst	r3			; any devices done?
	bne	16$			; yes
	output	#none

16$:	add	#2,sp			; restore stack
	return

4$:	cmp	(sp),#"KB
	bne	5$
	mov	r0,xrb
	add	#6,xrb
	.peek
	bit	#8192.,xrb
	bne	15$

5$:	tst	r3
	bne	6$
	output	#slbms2				; 'Device      Job    Why'

6$:	inc	r3
	mov	(sp),cmd			; might as well use cmd for
						; output - don't need it now
	asrb	temp				; get job number
	calls	l$cvtnum,<#cmd+2,r5,#-2>	; do the unit number
	mov	#"  ,cmd+4
	mov	#"  ,cmd+6
	mov	#"  ,cmd+8.
	mov	#"  ,cmd+10.			; do some formatting
	calls	l$cvtnum,<#cmd+12.,temp,#-2>	; do the job number
	mov	r0,xrb
	add	#6.,xrb
	.peek
	mov	xrb,tmp1
	movb	#32.,cmd+15.
	mov	#"  ,cmd+16.
	mov	#"  ,cmd+18.
	output	#cmd,#21.			; print the simple stuff
	bit	#32768.,tmp1
	beq	7$
	output	#as				; assigned

7$:	tstb	tmp1
	beq	8$
	output	#open

8$:	cmpb	cmd,#'M				; this device a tape?
	bne	10$				; no
	mov	r0,xrb
	add	#24.,xrb
	.peek
	tstb	xrb+1
	bne	9$
	output	#dos
	br	10$

9$:	output	#ansi

10$:	output	#crlf,#2
	jmp	15$

slbms1:	.asciz	/Busy devices:/
	.even
slbms2:	.asciz	<13.><10.>/Device      Job    Why/<13.><10.>
	.even
as:	.asciz	/AS /
	.even
open:	.asciz	/Open /
	.even
ansi:	.asciz	/ANSI/
	.even
dos:	.asciz	/DOS/
	.even
none:	.asciz	/None/<13.><10.>
	.even
temp:	.word	0
tmp1:	.word	0
slgfrm:	.ascii	/       Chan                                                 /
	.ascii	/                                                            /
	.even
out:	.blkb	80.
linfrm:	.ascii	'      **,**   Det               /  K                  .      /'
	.ascii	'               '<13.><10.>
	.blkb	20.
	.even

devcnt:	.word	0
devptr:	.word	0
memlst:	.word	0
untclu:	.word	0
untcnt:	.word	0
satctl:	.word	0
jsbtbl:	.word	0
satctm:	.word	0
untown:	.word	0
frees:	.word	0
devnam:	.word	0
csrtbl:	.word	0
devokb:	.word	0
ttyhct:	.word	0
jobcnt:	.word	0
rtslst:	.word	0
erlctl:	.word	0
sndlst:	.word	0
lognam:	.word	0
devsyn:	.word	0
memsiz:	.word	0
ccllst:	.word	0
del:	.word	0
fcblst:	.word	0
ddctbl:	.word	0
ucttbl:	.word	0

gtdknm:	mov	devokb,r3
	sub	#2,r3			; limit for outer loop
	clr	r2
	clr	r0

2$:	mov	devnam,xrb
	add	r2,xrb
	.peek
	mov	xrb,r4			; disk type for this loop
	mov	devcnt,xrb
	add	r2,xrb
	.peek
	mov	xrb,r1			; limit for internal loop
	blt	4$			; are there any to do?
	clr	r0

3$:	mov	r4,dsknam(r5)		; save disk type
	add	#2,r5
	mov	r0,dsknam(r5)		; & number
	add	#48.,dsknam(r5)		; and change to ASCII
	add	#2,r5
	inc	r0
	cmp	r0,r1
	ble	3$

4$:	add	#2,r2
	cmp	r2,r3
	ble	2$
	return

slashd:	bit	#2048.,flag		; do they want it?
	bne	1$			; yes
	return				; no

1$:	output	#crlf,#2
	output	#sldms1			; do header
	mov	satctl,-(sp)		; again, use stack as a data store
	mov	untclu,-(sp)
	mov	untcnt,-(sp)
	mov	lognam,-(sp)
	mov	#0,-(sp)		; don't set this up here, but reserve
					; some space for it on the stack
	mov	untown,-(sp)
	mov	sp,r5			; use r5 as a pointer to the store
					; now (r5)=untown, 4(r5)=lognam,
					; 6(r5)=untcnt, 8(r5)=untclu,
					; 10(r5)=satctl
	mov	devokb,r4
	sub	#2,r4			; set up limit for outer (r3) loop
	clr	r3			; from 0 to above

2$:	mov	devnam,xrb
	add	r3,xrb
	.peek
	save	xrb			; (sp) = this type of device
	clr	r1			; inner loop from 0 to...
	mov	devcnt,xrb
	add	r3,xrb
	.peek
	mov	xrb,r2			; what is now in r2
	bgt	4$			; yes, want to do it
	jmp	31$

4$:	mov	6(r5),xrb
	.peek
	mov	xrb,2(r5)		; store for later
	bge	3$			; yes, we want to do this one
	jmp	30$			; no, do next

3$:	movc	#sldfrm,#out,#48.	; set up
	mov	(sp),out		; retrieve disk name
	calls	l$cvtnum,<#out+2,r1,#-2> ; do disk number
	mov	2(r5),r0
	asl	r0
	asl	r0
	asl	r0
	asl	r0
	asl	r0
	asl	r0
	asl	r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	calls	l$cvtnum,<#out+4,r0,#4> ; do no. of open files
	bit	2(r5),#4096.
	beq	5$
	mov	8.(r5),xrb
	.peek
	movb	xrb,r0
	calls	l$cvtnum,<#out+29.,r0,#4> ; do clustersize
	clr	r0
	bisb	xrb+1,r0
	calls	l$cvtnum,<#out+34.,r0,#4> ; do errors

5$:	mov	10.(r5),xrb
	.peek
	mov	xrb,cmd			; low word of free - save
	mov	10.(r5),xrb
	add	satctm,xrb
	sub	satctl,xrb
	.peek
	mov	xrb,cmd+2		; high word of free - save
	calls	l$cvtli,<#out+16.,cmd+2,cmd> ; convert the free
	mov	#out+17.,r0		; want to trim leading 0's

6$:	cmpb	(r0),#'0
	bne	7$			; not a zero means we've trimmed all
	movb	#32.,(r0)+		; clear the zero
	jmp	6$			; and look for more

7$:	mov	untown,xrb
	add	untclu,xrb
	sub	untcnt,xrb
	add	10.(r5),xrb
	sub	satctl,xrb
	.peek
	mov	xrb,xrb+4
	mov	untclu,xrb
	add	10.(r5),xrb
	sub	satctl,xrb
	.peek
	save
	clr	r2
	movb	xrb,r0
	calls	l$cvtnum,<#out+30.,r0,#3> ; do the clustersize, while we're here
	clr	r3
	add	#2,xrb+4

10$:	add	xrb+4,r2
	bcc	11$
	inc	r3

11$:	sob	r0,10$
	calls	l$cvtli,<#out+8.,r3,r2>
;
;	All the above was to find out the disk size.  It can be greater
;	than 65536, and we can't do a mul, as that would be 2's cmp, so
;	we have to duplicate the mul routine for absolute binary.  r2 starts
;	off with the size of the disk in clusters, and we multiply it
;	by the clustersize to obtain the size in blocks.
;
	mov	#out+9.,r0

8$:	cmpb	(r0),#'0
	bne	9$			; trim 0's again
	movb	#32.,(r0)+
	br	8$

9$:	mov	r3,-(sp)		; now want % free
	mov	r2,r3
	mov	(sp)+,r2		; rearrange size in right order
	mov	cmd,r1
	mov	cmd+2,r0		; get the free
	div	#100.,r2		; won't work for size >32767*100
	div	r2,r0			; but who cares ? that's 3200M
	calls	l$cvtnum,<#out+26.,r0,#2> ; do % free
	unsave
	mov	8.(r5),xrb
	.peek
	movb	xrb+1,r0
	calls	l$cvtnum,<#out+35.,r0,#3> ; do errors
	mov	4(r5),xrb
	.peek
	calls	radasc,<#out+40.,xrb>	; first three letters of diskname
	mov	4(r5),xrb
	add	#2,xrb
	.peek
	calls	radasc,<#out+43.,xrb>	; next three letters of diskname
	output	#out,#48.		; print stuff so far
	bit	#16384.,2(r5)
	beq	12$
	output	#pri
	br	13$

12$:	output	#pub

13$:	mov	#512.,r0
	mov	#slddta,temp

14$:	bit	r0,2(r5)
	beq	15$
	output	temp,#5

15$:	asl	r0
	add	#5,temp
	cmp	r0,#8192.
	ble	14$			; do some info
	mov	(r5),xrb
	.peek
	mov	xrb,r0
	bit	#256.,r0
	beq	16$
	output	#dirty			; disk needs cleaning...

16$:	bit	#16384.,2(r5)
	beq	19$
	bit	#4096.,2(r5)
	beq	19$
	bit	#1,r0			; owned by job
	bne	17$			; no, system
	output	#sldjb			; ', Job '
	swab	r0
	clrb	r0
	swab	r0
	asr	r0			; get job number that owns the disk
	calls	l$cvtnum,<#out,r0,#-3>
	output	#out,#3			; output the job number
	br	19$

17$:	output	#system			; system owns disk

19$:	output	#crlf,#2
	
30$:	add	#2,10.(r5)
	add	#2,8.(r5)
	add	#2,6(r5)
	add	#10.,4(r5)
	add	#2,(r5)
	inc	r1
	cmp	r1,r2
	bgt	31$
	jmp	4$			; do next of this type

31$:	tst	(sp)+			; restore stack
	add	#2,r3
	cmp	r3,r4
	bgt	32$
	jmp	2$			; do next type

32$:
20$:	add	#12.,sp			; restore space used for data
	return

slashf:	bit	#4096.,flag		; do they want it?
	bne	1$			; yes
	return

1$:	output	#crlf,#2
	output	#slfms1			; do header
	movc	#slffrm,#out,#45.
	mov	erlctl,xrb
	.peek				; get total no. of errors
	mov	xrb,r1
	mov	ttyhct,xrb
	.peek
	mov	xrb,r0
	ble	2$
	sub	r0,r1			; exclude tty errors

2$:	mov	frees,xrb
	add	#2,xrb
	.peek
	calls	l$cvtnum,<#out,xrb,#5>	; get general buffers
	mov	frees,xrb
	sub	#2,xrb
	.peek
	calls	l$cvtnum,<#out+9.,xrb,#5> ; get FIP buffers
	mov	jobcnt,xrb
	.peek
	mov	xrb,r2
	movb	r2,r3
	calls	l$cvtnum,<#out+19.,r3,#3>	; do current # of jobs
	swab	r2
	movb	r2,r3
	calls	l$cvtnum,<#out+23.,r3,#-3>	; do jobmax
	calls	l$cvtnum,<#out+30.,r0,#5>	; do hung TTY's
	calls	l$cvtnum,<#out+39.,r1,#5>	; do errors
	output	#out,#45.
	output	#crlf,#2

20$:	output	#crlf,#2
	return

slashl:	bit	#8192.,flag			; do they want it ?
	bne	1$				; yes
	return					; no

1$:	output	#crlf,#2
	mov	rtslst,r1
	add	#2,r1
	output	#sllms1
	clr	temp

2$:	mov	r1,xrb
	.peek
	mov	xrb,r1
	bne	3$				; at end of list?
	return					; yes

3$:	tst	temp				; have we printed a header?
	bne	4$				; yes
	output	#sllms2

4$:	inc	temp
	mov	r1,xrb
	add	#26.,xrb
	.peek
	mov	xrb,r2
	mov	r1,xrb
	add	#14.,xrb
	.peek
	mov	xrb,r3
	mov	r1,xrb
	add	#30.,xrb
	.peek
	mov	xrb,r4
	movc	#sllfrm,#out,#45.
	mov	r1,xrb
	add	#2,xrb
	.peek
	calls	radasc,<#out,xrb>
	mov	r1,xrb
	add	#4,xrb
	.peek
	calls	radasc,<#out+3,xrb>		; do the name
	mov	r1,xrb
	add	#28.,xrb
	.peek
	movb	xrb+1,r0
	calls	l$cvtnum,<#out+9.,r0,#3>	; do protection code
	mov	r1,xrb
	add	#6,xrb
	.peek
	movb	xrb+1,r0
	calls	l$cvtnum,<#out+17.,r0,#3>	; proj
	movb	xrb,r0
	calls	l$cvtnum,<#out+21.,r0,#-3>	; prog
	movb	r3,r0
	calls	l$cvtnum,<#out+29.,r0,#2>	; size
	movb	r2,r0
	calls	l$cvtnum,<#out+36.,r0,#3>	; no. of users
	output	#out,#43.
	bit	#512.,r3
	beq	5$
	bit	#^B1111110100000000,r3
	bne	5$
;	bit	r3,#-256.
;	beq	5$
	output	#nonres
	br	8$

5$:	bit	#1024.,r3
	beq	6$
	output	#load
	br	8$

6$:	tst	r2
	blt	7$
	output	#slrtmp
	br	8$

7$:	output	#perm

8$:	output	#addr
	mov	r1,xrb
	add	#16.,xrb
	.peek
	mov	xrb,r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	calls	l$cvtnum,<#out,r0,#-4>
	output	#out,#4
	mov	#slrms3,-(sp)
	mov	#512.,r0

9$:	bit	r0,r4
	beq	10$
	mov	(sp),r5
	output	r5,#5

10$:	add	#5,(sp)
	asl	r0
	cmp	r0,#4096.
	ble	9$
	tst	(sp)+				; do the comments (like RTS)

19$:	output	#crlf,#2
	jmp	2$				; do next

slashm:	bit	#16384.,flag		; do they want it?
	bne	21$			; yes
	return

21$:	output	#crlf,#2
	output	#slmms1
	mov	sndlst,xrb
	.peek
	mov	xrb,r1
	bne	1$				; any receivers?
	output	#none
	output	#crlf,#2
	return					; no, give up

1$:	output	#slmms2

2$:	movc	#slmfrm,#out,#56.
	mov	r1,xrb
	add	#8.,xrb
	.peek
	movb	xrb,r2				; job number*2
	movb	xrb+1,r0
	calls	l$cvtnum,<#out+21.,r0,#2>	; obj (??)
	mov	r1,xrb
	add	#2,xrb
	.peek
	mov	xrb,out
	mov	r1,xrb
	add	#4,xrb
	.peek
	mov	xrb,out+2
	mov	r1,xrb
	add	#6,xrb
	.peek
	mov	xrb,out+4			; get name
	mov	r2,r0
	asr	r0
	calls	l$cvtnum,<#out+8.,r0,#3>	; job number
	mov	r1,xrb
	add	#10.,xrb
	.peek
	movb	xrb+1,r0
	calls	l$cvtnum,<#out+16.,r0,#2>	; RIB number
	mov	r1,xrb
	add	#12.,xrb
	.peek
	calls	l$cvtnum,<#out+27.,xrb,#5>	; buffer max
	mov	r1,xrb
	add	#14.,xrb
	.peek
	movb	xrb+1,r0
	calls	l$cvtnum,<#out+34.,r0,#3>	; messages queued
	movb	xrb,r0
	calls	l$cvtnum,<#out+38.,r0,#-3>	; message maximum
	mov	r1,xrb
	add	#20.,xrb
	.peek
	movb	xrb+1,r0
	calls	l$cvtnum,<#out+46.,r0,#3>	; links
	movb	xrb,r0
	calls	l$cvtnum,<#out+50.,r0,#-3>	; max
	output	#out,#55.
	mov	#slmms4,-(sp)			; now for some info
	mov	#1.,r0
	mov	r1,xrb
	add	#10.,xrb
	.peek
	movb	xrb,r5
	bit	#2,r5
	beq	3$
	bit	#1,r5
	beq	3$
	sub	#1,r5				; don't want Lcl Prv, just Prv

3$:	bit	r0,r5
	beq	4$
	mov	(sp),r4
	output	r4,#4

4$:	add	#4,(sp)
	asl	r0
	cmp	r0,#128.
	ble	3$
	tst	(sp)+

	output	#crlf,#2
	mov	r1,xrb
	.peek
	mov	xrb,r1
	beq	20$
	jmp	2$				; next

20$:	return
slmms1:	.asciz	/Message Receivers:/<13.><10.>
	.even
slmms2:	.ascii	'Rcvrid   Job    Rib  Obj  Buffer Msgs/Max   Links/MAX  '
	.asciz	/Access/<13.><10.>
	.even
slmms4:	.asciz	/ Lcl Prv Net One Ncs ??? Evt XOF/
	.even
slmfrm:	.ascii	'                                     /'
	.asciz	'           /      '
	.even
sllms1:	.asciz	/Resident Libraries:/<13.><10.>
	.even
sllms2:	.ascii	/ Name    Prot     Acct      Size    Users   Comments/<13.>
	.asciz	<10.>
	.even
sllfrm:	.asciz	/        <   >   [   ,   ]      K            /
	.even
slfms1:	.ascii	/General  FIP                    Hung/<13.><10.>
	.asciz	"Buffers  Buffers  Jobs/Jobmax   TTY's   Errors"<13.><10.>
slffrm:	.asciz	'                      /                              '

sldms1:	.ascii	/Disk Structure:/<13.><10.>
	.ascii	/Dsk Open    Size       Free   Clu  Err  Name    Comments/
	.asciz	<13.><10.>
	.even
sldfrm:	.asciz	/                            %                               /
	.even
pri:	.asciz	/Pri/
pub:	.asciz	/Pub/
slddta:	.asciz	/, NFF, R-O, DLW, NFS, Lck/
	.even
dirty:	.asciz	/, Dirty/
	.even
sldjb:	.asciz	/, Job /
	.even
system:	.asciz	/, System/
	.even

slashr:	bit	#1024.,flag		; do they want it?
	bne	2$
	jmp	20$

2$:	mov	rtslst,r1		; get root pointer
	bne	3$
	jmp	20$

3$:	mov	r1,xrb
	sub	#2,xrb
	.peek
	mov	xrb,r2			; default KBM pointer
	output	#slrms1			; print header

1$:	movc	#rtsfrm,#out,#32.	; set up format for line
	mov	r1,xrb
	.peek
	mov	xrb,r1			; get next rts
	bne	4$			; and there was one
	jmp	20$

4$:	add	#2,xrb
	.peek
	calls	radasc,<#out,xrb>	; first three rts name chars.
	mov	r1,xrb
	add	#4,xrb
	.peek
	calls	radasc,<#out+3,xrb>	; and next three
	mov	r1,xrb
	add	#6,xrb
	.peek
	calls	radasc,<#out+8.,xrb>	; file extension
	mov	r1,xrb
	add	#14.,xrb
	.peek
	mov	xrb,r3			; used for two things, so store it
	movb	r3,r0
	calls	l$cvtnum,<#out+16.,r0,#2> ; size of rts
	mov	r1,xrb
	add	#28.,xrb
	.peek
	movb	xrb,r0
	calls	l$cvtnum,<#out+19.,r0,#2> ; max job size of job under that rts
	mov	r1,xrb
	add	#26.,xrb
	.peek
	mov	xrb,r4			; save for later
	movb	xrb,r0
	calls	l$cvtnum,<#out+25.,r0,#2> ; number of current users
	output	#out,#32.
	bit	#512.,r3
	beq	5$
	output	#nonres			; non-resident
	br	8$

5$:	bit	#1024.,r3
	beq	6$
	output	#load			; loading
	br	8$

6$:	tst	r4
	blt	7$
	output	#slrtmp			; temporarily resident
	br	8$

7$:	output	#perm

8$:	mov	r1,xrb
	add	#16.,xrb
	.peek
	tst	xrb
	beq	9$
	mov	xrb,r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	output	#addr
	calls	l$cvtnum,<#out,r0,#-4> ; do address
	output	#out,#4			; and print it

9$:	mov	r1,xrb
	add	#30.,xrb
	.peek
	mov	xrb,r0
	bit	#256.,r0
	beq	11$
	cmp	r1,r2
	bne	12$
	output	#dfkbm			; default keyboard monitor
	br	11$

12$:	output	#kbm

11$:	mov	#slrms3,-(sp)
	mov	r0,-(sp)
	mov	#512.,r0
13$:	bit	r0,(sp)
	beq	15$
	mov	2(sp),temp
	output	temp,#5
15$:	add	#5,2(sp)
	asl	r0
	cmp	r0,#8192.
	ble	13$
	mov	(sp)+,r0
	tst	(sp)+			; do some info

	tst	r0
	bge	10$
	output	#slremt
	swab	r0
	clrb	r0
	swab	r0
	calls	l$cvtnum,<#out,r0,#-3> ; do final bit of info (EMT)
	output	#out,#3

10$:	output	#crlf,#2
	jmp	1$

20$:	return

slrms3:	.asciz	', 1US, R/W, NER, REM, CSZ'
	.even
nonres:	.asciz	/Non-Res/
	.even
load:	.asciz	/Loading/
	.even
slrtmp:	.asciz	/Temp/
	.even
perm:	.asciz	/Perm/
	.even
addr:	.asciz	/, Addr:/
	.even
dfkbm:	.asciz	/, DF KBM/
	.even
kbm:	.asciz	/, KBM/
	.even
slremt:	.asciz	/, EMT:/
	.even
dsknam:	.blkb	80.			; unlikely to have 20 drives
wntjob:	.word	0
wntppn:	.word	0
wntnm1:	.word	0
wntnm2:	.word	0
prog:	.blkb	10.
slrms1:	.ascii	/Run-Time Systems:/<13.><10.>/ Name   Typ       Size/
	.asciz	/  Users   Comments/<13.><10.>
	.even
rtsfrm:	.ascii	/                  (  )K/
	.asciz	/                                                           /
	.even
filscn:	.asciz	/[       ]/
	.blkb	5.
	.even
wntkb:	.word	0
ccl:	.word	0
job:	.word	0
kb:	.word	0
swap:	.word	0
contrl:	.word	0
cpu:	.word	0
cpu1:	.word	0
nam1:	.word	0
nam2:	.word	0
ppn:	.word
rts1:	.word	0
rts2:	.word	0
jbstat:	.word	0
jbwait:	.word	0
jbsiz:	.word	0
prirun:	.word	0
maxsiz:	.word	0
kbtmo:	.word	0
jdb:	.word	0
jdb2:	.word	0
stms1:	.asciz	/ status at /
	.even
sthed:	.ascii	'Job    Who    Where    What    Size    State    '
	.ascii	'Run-Time  Pri/RB   RTS'<13.><10.><0.>
	.even
swi:	.ascii	/A G N P S U     B   R D F L M /
	.word	0
flg:	.word	1.
	.word	2.
	.word	4.
	.word	8.
	.word	16.
	.word	32.
	.word	64.
	.word	128.
	.word	256.
	.word	512.
	.word	1024.
	.word	2048.
	.word	4096.
	.word	8192.
	.word	16384.
flag:	.word	0
swierr:	.asciz	/?Illegal Option or Argument/
	.even
prghed:	.asciz	/SYSTAT V1.0 /
	.even
prompt:	.asciz	/Output status to ? /
	.even
cmd:	.blkb	256.			; input buffer
defswi:	.asciz	'/SBRDFLM'		; default switches
	.even
slash:	.asciz	'/'			; MACRO is a bore
filerr:	.asciz	/?Error on output file : /
	.even
buf:	.blkb	512.			; buffer for .print
crlf:	.ascii	<13.><10.>

	.end	start

